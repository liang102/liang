[{"content":" shortcode code Alert 自定义一些alert简码 颜色调板 {{\u003c alert icon=\"pencli\" iconColor=\"#1d3557\" cardColor=\"#7775CA\" \u003e}} \"注意\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"list\" iconColor=\"#1d3557\" cardColor=\"#7EC0F0\" \u003e}} \"摘要\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"circle-info\" iconColor=\"#1d3557\" cardColor=\"#7EE0F0\" \u003e}} \"信息\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"lightbulb\" iconColor=\"#1d3557\" cardColor=\"#9AE07A\" \u003e}} \"技巧\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"check\" iconColor=\"#1d3557\" cardColor=\"#0CF219\" \u003e}} \"成功\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"question\" iconColor=\"#1d3557\" cardColor=\"#CFF227\" \u003e}} \"问题\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"triangle-exclamation\" iconColor=\"#1d3557\" cardColor=\"#F4F405\" \u003e}} \"警告\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"xmark\" iconColor=\"#1d3557\" cardColor=\"#DB8A7A\" \u003e}} \"失败\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"skull-crossbones\" iconColor=\"#1d3557\" cardColor=\"#E05896\" \u003e}} \"危险\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"bug\" iconColor=\"#1d3557\" cardColor=\"#F15661\" \u003e}} \"Bug\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"list-ol\" iconColor=\"#1d3557\" cardColor=\"#974AE8\" \u003e}} \"示例\" {{\u003c /alert \u003e}} {{\u003c alert icon=\"quote-right\" iconColor=\"#1d3557\" cardColor=\"#CBC6CF\" \u003e}} \"引用\" {{\u003c /alert \u003e}} 2024/03/23 · 19:53 · 深圳 shortcode code Alert 效果预览 注意 摘要 信息 技巧 成功 问题 警告 失败 危险 Bug 示例 引用 2024/03/23 · 19:53 · 深圳 ","date":"March 23, 2024","externalUrl":"","permalink":"/shcode/shortcode/","section":"Shcodes","summary":"主题作者提供的一些简码很自由，定义一些简码参数的编排，方便日后快速使用","title":"Shortcode","type":"shcode"},{"content":" 改变宽高范围 默认情况下，width 和 height 设置的是内容盒宽高。\n页面重构师：将psd文件（设计稿）制作为静态页面\n衡量设计稿尺寸时，往往使用的是边框盒，但设置width和height，则设置的是内容盒\n精确计算 CSS3: box-sizing 改变背景覆盖范围 默认情况下，背景覆盖边框盒 可以通过 background-clip 进行修改\n溢出处理 overflow, 控制内容溢出边框盒后的处理方式\n断词规则 word-bread，会影响文字在什么位置被截断换行。\nnormal：普通，CJK字符（文字位置截断），非CJK字符（单词位置截断）\nC：中国 J：日本 K：韩国 break-all：截断所有，所有字符都在文字处截断。\nkeep-all: 保持所有，所有文字都在单词之间截断。\n空白处理 white-space: nowrap\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day08/","section":"知识存档","summary":"盒模型应用","title":"8.盒模型应用","type":"docs"},{"content":" 菜单 blowfish 主题提供了三个菜单\nmain 菜单出现在网站标题中。 subnavigation 子菜单，出现在main菜单的下方。 footer 菜单出现在网站底部版权声明的正上方。 默认是独立的配置文件 menus.en.toml，确保该文件命名与站点配置中defaultContentLanguage 的语言代码相同。 若defaultContentLanguage = zh-cn, 则文件名为：menus.zh-cn.toml\n# 第一种配置菜单方式 [[main]] # 一级菜单标识 name = \u0026#34;博客\u0026#34; # 网站菜单目录名称 pre = \u0026#34;grav\u0026#34; # 菜单图标icon. svg图标名称 pageRef = \u0026#34;blog\u0026#34; # 网站菜单目录对应的路径 weight = 10 # 权重，数值大小用于排序。 # 第二种配置菜单的方式，嵌套菜单 [[main]] name = \u0026#34;菜单父目录\u0026#34; # 菜单父目录 weight = 20 # 权重，这个权重数值将 排在博客后面 [[main]] name = \u0026#34;子目录1\u0026#34; # 菜单子目录1 parent = \u0026#34;菜单父目录\u0026#34; # 指定菜单父目录 pageRef = \u0026#34;posts/one\u0026#34; # 菜单路径，即帖子存放路径 weight = 20 # 权重，与父目录保持一致。 [[main]] name = \u0026#34;子目录2\u0026#34; # 菜单子目录2 parent = \u0026#34;菜单父目录\u0026#34; # 指定菜单父目录 pageRef = \u0026#34;posts/two\u0026#34; # 菜单路径，即帖子存放路径, 路径可相同可不同。 weight = 20 # 权重，与父目录保持一致。 # 菜单配置链接方式 [[main]] identifier = \u0026#34;github\u0026#34; # 菜单名称 pre = \u0026#34;github\u0026#34; # icon 图标名称 url = \u0026#34;https://github.com/nunocoracao/blowfish\u0026#34; # 菜单链接 weight = 30 # 权重 # 二级菜单配置方式,子导航菜单 [[subnavigation]] # 二级菜单标识 name = \u0026#34;二级菜单\u0026#34; # 二级菜单名称 pageRef = \u0026#34;/docs/some\u0026#34; # 二级菜单对应路径 weight = 10 # 二级菜单权重 # 页脚菜单 [[footer]] # 页脚菜单标识 name = \u0026#34;标签\u0026#34; # 页脚菜单名称 pageRef = \u0026#34;tages\u0026#34; # 页脚菜单对应路径 weight = 20 # 权重 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/menus/","section":"知识存档","summary":"网站主页菜单布局教程","title":"Blowfish主题菜单设置","type":"docs"},{"content":" hugo 评论参考 hugo-theme-stack 主题 本文评论指南 本文主要添加以下三个评论系统。\nTwikoo Waline giscus 添加评论 首先讲讲如何简单的添加评论，根据主题作者预留评论位置，只需要加一个comments.html文件即可。 启用评论配置 blowfish主题默认给我们预留了文章评论的功能，需要在配置文件config/default/params 中找到article.showComments该参数并启用true\n[article] showComments = true 登录 giscus 配置连接仓库 安装 giscus app 复制这段代码，待会有用。 添加Giscus评论 在博客目录下的layouts/partials/这个位置添加comments.html文件。 然后就OK了。 mkdir layouts/partials/\r# 编辑comment.html 文件, 将复制的代码贴进来。\r\u0026lt;div class=\u0026#34;comment\u0026#34; id=\u0026#34;giscus\u0026#34;\u0026gt;\r\u0026lt;script src=\u0026#34;https://giscus.app/client.js\u0026#34;\rdata-repo=\u0026#34;\u0026#34; # 仓库地址()\rdata-repo-id=\u0026#34;\u0026#34; # 仓库id()\rdata-category=\u0026#34;\u0026#34; # 分类名\rdata-category-id=\u0026#34;\u0026#34; # 分类id\rdata-mapping=\u0026#34;pathname\u0026#34;\rdata-strict=\u0026#34;0\u0026#34;\rdata-reactions-enabled=\u0026#34;1\u0026#34;\rdata-emit-metadata=\u0026#34;0\u0026#34;\rdata-input-position=\u0026#34;top\u0026#34;\rdata-theme=\u0026#34;preferred_color_scheme\u0026#34;\rdata-lang=\u0026#34;zh-CN\u0026#34;\rdata-loading=\u0026#34;lazy\u0026#34;\rcrossorigin=\u0026#34;anonymous\u0026#34;\rasync\u0026gt;\r\u0026lt;/script\u0026gt;\r\u0026lt;/div\u0026gt; 自定义评论 需要对主题页面进行一点点修改。 扩展评论系统，可以自由选择评论。 支持页面和文章区展示评论。 single.html 控制文章布局 list.html 控制列表布局 修改主题文章布局配置文件 不要动主题下的布局文件 在博客目录下的layouts/_default/这个位置，添加一个single.html文件。 mkdir layouts/_default/ cp theme/blowfish/layouts/_default/single.html layouts/_default/ 编辑layouts/_default/single.html 文件 {{ if .Params.showComments | default (.Site.Params.article.showComments | default false) }} {{ if templates.Exists \u0026#34;partials/comments.html\u0026#34; }} \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; \u0026lt;hr class=\u0026#34;border-dotted border-neutral-300 dark:border-neutral-600\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; {{ partial \u0026#34;comments.html\u0026#34; . }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ else }} {{ warnf \u0026#34;[BLOWFISH] Comments are enabled for %s but no comments partial exists.\u0026#34; .File.Path }} {{ end }} {{ end }} # 将上面这段代码换成下面这样 {{ if .Params.Comments.enable | default (.Site.Params.Comments.enable | default false) }} {{ $comment := .Params.Comments.provider | default .Site.Params.Comments.provider }} {{ $provider := print \u0026#34;partials/Comments/\u0026#34; $comment \u0026#34;.html\u0026#34; }} {{ if templates.Exists $provider }} \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; \u0026lt;hr class=\u0026#34;border-dotted border-neutral-300 dark:border-neutral-600\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; {{ partial $provider . }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ else }} {{ warnf \u0026#34;[BLOWFISH] Comments are enabled for %s but no $provider partial exists.\u0026#34; .File.Path }} {{ end }} {{ end }} 添加评论 在博客目录下layouts/partials/ 创建一个Comments目录。 评论系统都放到这个目录下，按照评论系统名称命名。例如：giscus评论，则giscus.html mkdir layouts/partials/Comments cd layouts/partials/ mv comments.html Comments/giscus.html 为展示效果，再添加两个评论，Twikoo 和 Waline\nTwikoo 41 字\u0026middot; loading \u0026middot; loading twikoo Twikoo评论部署指南 配置Twikoo评论 在layouts/partials/Comments目录下创建一个twikoo.html文件 # 添加以下内容 \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/twikoo/{{ .Site.Params.twikoo.version }}/twikoo.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; twikoo.init({ envId: \u0026#39;https://xxx.vercel.app\u0026#39;, // Twikoo服务端地址 el: \u0026#39;#tcomment\u0026#39;, //lang: \u0026#39;zh-CN\u0026#39;, //region: \u0026#39;ap-shanghai\u0026#39;, //path: \u0026#39;pathname\u0026#39;, }); \u0026lt;/script\u0026gt; Waline 33 字\u0026middot; loading \u0026middot; loading waline Waline评论部署指南 配置Waline评论 在layouts/partials/Comments目录下创建一个waline.html文件 \u0026lt;link href=\u0026#34;https://unpkg.com/@waline/client@v3/dist/waline.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/@waline/client@v3/dist/waline.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;waline\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import { init } from \u0026#39;https://unpkg.com/@waline/client@v3/dist/waline.js\u0026#39;; init({ el: \u0026#39;#waline\u0026#39;, meta: [\u0026#39;nick\u0026#39;,\u0026#39;mail\u0026#39;,\u0026#39;link\u0026#39;], // 评论属性 requiredMeta: [\u0026#39;nick\u0026#39;,\u0026#39;mail\u0026#39;], // 必填项，昵称与邮件 login: \u0026#39;force\u0026#39;, // 登录后访问 comment: true, // 评论数统计 placeholder: \u0026#39;欢迎评论\u0026#39;, // 评论框占位提示符 serverURL: \u0026#34;https://xxx.vercel.app\u0026#34;, // Waline 服务端地址 avatar: \u0026#34;wavatar\u0026#34;, // 头像 avatarCDN: \u0026#34;https://sdn.geekzu.org/avatar/\u0026#34;, // 头像cdn pageSize: 10, // 评论每页条数 lang: \u0026#34;zh-CN\u0026#34;, // 语言 visitor: true, // 文章访问量统计 highlight: true, // 代码高亮 uploadImage: false, // 评论上传图片功能 emoji: \u0026#34;https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo\u0026#34; // emoji 表情包 }) \u0026lt;/script\u0026gt; 修改配置文件 编辑配置文件config/_default/params.toml # 在空白处添加以下内容 Comments # 是否开启文章评论 enable = true # 全局指定文章评论giscus |twikoo |waline provider = \u0026#34;giscus\u0026#34; 在文章中也可以控制评论系统，只需要在 font matter 处添加 Comments: provider: \u0026#34;waline\u0026#34; 修改主题页面布局配置文件 在博客目录下layouts/_default/ 添加一个list.html文件 cp theme/blowfish/layouts/_default/list.html layouts/_default/ 编辑list.html文件 # 在 {{ partial \u0026#34;pagination.html\u0026#34; . }} 这行的下面添加以下内容 {{ if .Params.pageComments.enable | default (.Site.Params.pageComments.enable | default false) }} {{ $comment := .Params.pageComments.provider | default .Site.Params.Comments.provider }} {{ $provider := print \u0026#34;partials/Comments/\u0026#34; $comment \u0026#34;.html\u0026#34; }} {{ if templates.Exists $provider }} \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; \u0026lt;hr class=\u0026#34;border-dotted border-neutral-300 dark:border-neutral-600\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;pt-3\u0026#34;\u0026gt; {{ partial $provider . }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ else }} {{ warnf \u0026#34;[BLOWFISH] Comments are enabled for %s but no $provider partial exists.\u0026#34; .File.Path }} {{ end }} {{ end }} 修改配置文件 编辑配置文件config/_default/params.toml # 在空白处添加以下内容 pageComments # 是否开启分页评论。不建议全局开启，可在有需要页面开启。 enable = false Font Matter 填写 文章级别index.md # 开启 --- Comments: enable: true # 如果全局已开启，这条可以忽略 provider: \u0026#34;twikoo\u0026#34; --- # 关闭 --- Comments: enable: false --- 页面级别_index.md # 开启 --- pageComments: enable: true provider: \u0026#34;giscus\u0026#34; --- # 关闭 --- pageComments: enable: false --- ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/comment/","section":"知识存档","summary":"添加评论","title":"Blowfish主题添加评论","type":"docs"},{"content":" Twikoo 评论部署 详细配置，请查看 Twikoo 文档 本教程使用 vercel部署 注册一个 MongoDB 账号 创建一个免费的MongoDB数据库，选择FREE类型的，aws厂商提供，地区我这里选择的是香港。 创建一个MongoDB数据库用户。 开放网络地址访问，允许所有网络进行连接。 在 Database 页面点击 Connect，选择 Drivers，复制数据库连接字符串，将连接字符串中的 : 修改为刚刚创建的数据库 用户名:密码。 申请 Vercel 账号。连接github第三方服务登录。可以在设置中查看和管理三方服务的连接登录。 点击以下按钮将 Twikoo 一键部署到 Vercel 添加环境变量。进入项目设置settings \u0026mdash;- 环境变量Environment Variables，添加环境变量key: MONGODB_URI value: 将前面复制的数据库连接字符串粘贴到这里 修改功能区，无服务器函数的区域，选择与MongoDB数据库相同的地区。我前面MongoDB选择的是香港，这里也选择香港。 重新部署，是环境变量生效 部署成功后会看到云函数运行正常。 配置自定义域名，修改域名DNS解析，将解析cname 到 cname.vercel-dns.com这个域名上，才能访问成功。 ","date":"January 1, 1","externalUrl":"","permalink":"/posts/twikoo/","section":"笔记","summary":"Twikoo评论部署指南","title":"Twikoo","type":"posts"},{"content":" Waline 评论部署 本教程使用 vercel 部署，其他部署渠道请查看 valine配置文档 注册一个 LeanCloud 国际版 账号\n创建一个应用, 在设置里的应用凭证会看到AppID AppKey MasterKey，后续会用到。\n点击下方按钮，跳转至 Vercel 进行 Server 端部署。跟twikoo 部署步骤一样，这里就不详细说了，创建一个仓库，例如：valine-api 给该项目添加3个环境变量，LEAN_ID 值对应 AppID, LEAN_KEY 值对应AppKey 和 LEAN_MASTER_KEY 值对应 MasterKey。 重新部署，使环境变量生效。看到评论框代表部署成功。 添加自定义域名，配置域名DNS解析cname 到 cname.vercel-dns.com这个域名上，才能访问成功。如下图。 ","date":"January 1, 1","externalUrl":"","permalink":"/posts/waline/","section":"笔记","summary":"Waline评论部署指南","title":"Waline","type":"posts"},{"content":" Linux 服务器安装新版本curl curl-8.9.0 ca证书 mkdir /opt/curl cd /opt/curl wget https://github.com/stunnel/static-curl/releases/download/8.9.0/curl-linux-x86_64-8.9.0.tar.xz tar -xf curl-linux-x86_64-8.9.0.tar.xz wget https://curl.se/ca/cacert.pem cp cacert.pem /etc/ssl/certs/ca-certificates.crt ","date":"January 1, 1","externalUrl":"","permalink":"/posts/curl/","section":"笔记","summary":"方便验证h2服务","title":"配置curl 支持h2","type":"posts"},{"content":" 自定义简码 实现简码说说功能 实现简码网易云音乐功能 Artitalk 说说简码 请仔细阅读 官方文档 并创建一个说说应用。 在博客目录layouts/shortcodes下创建artitalk.html文件 mkdir layouts/shortcode \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://unpkg.com/artitalk\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 存放说说的容器 --\u0026gt; \u0026lt;div id=\u0026#34;artitalk_main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Artitalk({ appId: \u0026#34;{{ .Get \u0026#34;appId\u0026#34; }}\u0026#34;, appKey: \u0026#34;{{ .Get \u0026#34;appKey\u0026#34; }}\u0026#34;, atEmoji: { weibo: \u0026#34;https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo\u0026#34;, bilibili: \u0026#34;https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili\u0026#34;, qq: \u0026#34;https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq\u0026#34;, baiyan: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/baiyan.png\u0026#34;, bishi: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bishi.png\u0026#34;, bizui: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/bizui.png\u0026#34;, chan: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/chan.png\u0026#34;, daku: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/daku.png\u0026#34;, dalao: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/dalao.png\u0026#34;, dalian: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/dalian.png\u0026#34;, dianzan: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/dianzan.png\u0026#34;, doge: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/doge.png\u0026#34;, facai: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/facai.png\u0026#34;, fadai: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/fadai.png\u0026#34;, fanu: \u0026#34;https://cdn.jsdelivr.net/gh/Artitalk/Artitalk-emoji/fanu.png\u0026#34;, }, }) \u0026lt;/script\u0026gt; 网易云音乐简码 在博客目录layouts/shortcodes下创建music.html文件 \u0026lt;div id=\u0026#34;music\u0026#34;\u0026gt; \u0026lt;iframe frameborder=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; marginwidth=\u0026#34;0\u0026#34; marginheight=\u0026#34;0\u0026#34; width=330 height=86 src=\u0026#34;//music.163.com/outchain/player?type=2\u0026amp;id={{ .Get 0 }}\u0026amp;auto=0\u0026amp;height=66\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; 简码调用 {{\u0026lt; artitalk appId=\u0026#34;Your LeanCloud appId\u0026#34; appKey=\u0026#34;Your LeanCloud appKey\u0026#34; \u0026gt;}} {{\u0026lt; music \u0026#34;网易云音乐id号\u0026#34; \u0026gt;}} ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/shortcodes/","section":"知识存档","summary":"添加说说、网易云音乐简码功能","title":"自定义简码功能","type":"docs"},{"content":" 不蒜子统计 code 今天更新了网站主页访客总数统计，使用不蒜子进行统计。\n不蒜子文档\n不蒜子的极简写法\n本站总访问量\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 本站访客数\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;人次 本文总阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 从主题 copy head.html 和 footer.html 文件到 layouts/partials/ cp theme/blowfish/layouts/partials/head.html layouts/partials/ cp theme/blowfish/layouts/partials/footer.html layouts/partials/ 修改head.html文件 # 编辑layouts/partials/head.html文件，在 Firebase 两个 end 后边行添加以下代码 150 {{/* busuanzi */}} 151 {{ if .IsHome }} 152 {{ if .Params.busuanzi | default (.Site.Params.busuanzi.enable | default false) }} 153 \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 154 \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; 155 {{ end }} 156 {{ end }} 修改footer.html文件 # 编辑layouts/partials/footer.html文件，在 Copyright 代码后边一个end 大约36行添加以下代码 38 \u0026lt;br\u0026gt; 39 {{/* busuanzi */}} 40 {{ if .IsHome }} 41 {{ if .Params.busuanzi | default (.Site.Params.busuanzi.enable | default false) }} 42 本站访客总数: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 43 {{ end }} 44 {{ end }} 修改主题配置文件: config/_default/params.toml\n# 在空白处添加以下代码 [busuanzi] enable = true 2024/3/26 · 0:16 · 深圳 ","date":"March 26, 2024","externalUrl":"","permalink":"/shcode/busuanzi/","section":"Shcodes","summary":"给网站添加不蒜子访问量统计","title":"Busuanzi","type":"shcode"},{"content":" 属性值的计算过程 一个元素一个元素依次渲染，顺序按照页面文档的树形目录结构进行 渲染每个元素的前提条件：该元素的所有CSS属性必须有值 一个元素，从所有属性都没有值，到所有的属性都有值，这个计算过程，叫做属性值的计算过程。 无属性值 \u0026mdash;-\u0026gt; 1.确定声明值 \u0026mdash;-\u0026gt; 2.层叠冲突 \u0026mdash;-\u0026gt; 3.使用继承 \u0026mdash;-\u0026gt; 4.使用默认值 \u0026mdash;-\u0026gt; 每个属性都有值\n确定声明值：参考样式表中没有冲突的声明，作为CSS属性值。 层叠冲突：对样式表有冲突的声明使用层叠规则，确定CSS属性值。 使用继承：对仍然没有值的属性，若可以继承，则继承父元素的值。 使用默认值：对仍然没有值的属性，使用默认值。 特殊的两个CSS取值： inherit：手动（强制）继承，将父元素的值取出应用到该元素。 initial：初始值，将该属性设置为默认值。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day07/","section":"知识存档","summary":"元素属性渲染的计算过程原理","title":"7.属性值的计算过程","type":"docs"},{"content":" 默认是独立的配置文件: languages.en.toml，确保该文件命名与站点配置中defaultContentLanguage 的语言代码相同。 若defaultContentLanguage = zh-cn, 则文件名为：languages.zh-cn.toml\n网站标题图标设置 仅支持图片, 图片路径可以是自定义。 [params] logo = \u0026#34;img/logo.png\u0026#34; # 网站标题logo 作者图标设置 仅支持图片, 图片路径可以是自定义。 [author] image = \u0026#34;img/avatar.png\u0026#34; # 作者头像设置 浏览器图标设置 网站图标生成器 网站图标转换器 将生成的图标放入static/目录下即可 unzip -d static favicon_package_v0.16.zip ls static/ android-chrome-192x192.png android-chrome-512x512.png apple-touch-icon.png favicon-16x16.png favicon-32x32.png favicon.ico site.webmanifest ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/face/","section":"知识存档","summary":"浏览器图标以及站点图标和作者图标教程","title":"网站图标设置","type":"docs"},{"content":"这个是一个段落测试\n\u0026emsp;\u0026emsp;这个是一个段落测试内容无关紧要\n\u0026emsp;\u0026emsp;这个是一个段落测试内容无关紧要\n\u0026emsp;\u0026emsp;这个是一个段落测试内容无关紧要\n\u0026emsp;\u0026emsp;这个是一个段落测试内容无关紧要\n\u0026emsp;\u0026emsp;这个是一个段落测试内容无关紧要\n","date":"March 26, 2024","externalUrl":"","permalink":"/shcode/test/","section":"Shcodes","summary":"test","title":"test","type":"shcode"},{"content":" 子元素会继承父元素的某些CSS属性。 若父元素没有设置该属性，则会再找父元素的父元素，直到html元素 若html元素也没有设置，则会根据浏览器设置，例如: font-size 属性 通常，跟文字内容相关的属性都能被继承。 通常都在body设置字体类型。 Inherited from div.container 继承 div 的样式 Inherited from body 继承 body 的样式 Inherited from html 继承 html 的样式 \u0026lt;style\u0026gt; .container{ color: red; font-size: 2em; line-height: 2.5; background-color: bisque; text-align: center; } body { font-family: Arial, Helvetica, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Vero, laboriosam aut, reprehenderit laudantium earum atque provident quasi optio doloremque nam ipsam repellat harum odit in eos quia. Assumenda, eveniet nihil! \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Id.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Repudiandae.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Molestiae!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Impedit!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Facere.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Maxime.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Eveniet?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Harum!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Facere!\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div\u0026gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Vero quos veritatis necessitatibus ea excepturi. Eaque totam dolorum laborum enim mollitia tempora ex, molestias sapiente, illo vel error in impedit porro? \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; ","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day06/","section":"知识存档","summary":"元素继承用例","title":"6.继承","type":"docs"},{"content":" 默认是独立的配置文件: params.toml. 该文件是使用主题blowfish所有配置。 这篇文章主要讲解如何配置网站的背景图。\n网站主页背景图设置 [homepage] # 找到主页的配置 homepageImage = \u0026#34;/img/images.jpg\u0026#34; 菜单功能里的背景图设置 defaultBackgroundImage = \u0026#34;/img/images.jpg\u0026#34; 文章背景图设置 当文章没有使用图片作为封面时，整个设置很有用。 defaultFeaturedImage = \u0026#34;/img/images.jpg\u0026#34; ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/background/","section":"知识存档","summary":"blowfish主题背景应用","title":"网站主题背景图设置","type":"docs"},{"content":" box：盒子，每个元素在页面中都会生成一个矩形区域（盒子box）\n盒子类型 行盒：display等于inline的元素。 块盒：display等于block的元素。 行盒在页面中不换行，块盒独占一行。\ndisplay默认值为inline\n浏览器默认样式表设置的块盒：容器元素、h1~h6、p\n常见的行盒：span、 a、 img、 video、 audio\n盒子的组成部分 无论是行盒、还是块盒，都由下面几个部分组成，从内到外分别是： 1. 内容 content - width 宽度 - height 高度 - 这两个值设置的盒子内容的宽高。 - 内容部分通常叫做整个盒子的**内容盒 content-box** 2. 填充(内边距) padding - 盒子的边框到盒子内容的距离 - padding-left 左内边距 - padding-right 由内边距 - padding-top 上内边距 - padding-bottom 下内边距 padding：简写属性(速写属性) padding：上 右 下 左 填充区+内容区域 = 填充盒 padding-box 3. 边框 border 边框 = 边框样式 + 边框宽度 + 边框颜色 边框样式: border-style 边框宽度： border-width 边框颜色：border-color\n边框+填充区+内容区 = 边框盒 border-box\n4. 外边距 margin 边框到其他盒子的距离 margin-top margin-left margin-right margin-bottom 速写属性：margin\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day05/","section":"知识存档","summary":"盒模型应用","title":"5.盒模型","type":"docs"},{"content":" 多名作者 如果你的网站有多个作者贡献内容，那么就需要多个作者。\n创建作者 在data目录下创建authors目录。 以作者名称为文件名，在data/authors/目录下创建一个作者名称.json文件。方便后续在文章中引用。 文件内容与languages.语言代码.toml文件里的author一样，只不过换成json的格式书写。 mkdir data/authors touch data/authors/小橘子Single.json # json 文件内容如下格式： { \u0026#34;name\u0026#34;: \u0026#34;小橘子Single\u0026#34;, \u0026#34;image\u0026#34; : \u0026#34;img/avatar.png\u0026#34;, \u0026#34;bio\u0026#34;: \u0026#34;如你所见\u0026#34;, \u0026#34;social\u0026#34;: [ { \u0026#34;github\u0026#34;: \u0026#34;https://github.com/liang102\u0026#34; } ] } 参数说明 name：作者名称 image：作者头像 bio: 作者简介 social：作者社交链接,支持多个社交链接 - email - link - amazon - apple - blogger - codepen - dev - discord - dribbble - facebook - flickr - foursquare - github - gitlab - google - hashnode - instagram - keybase - kickstarter - lastfm - linkedin - mastodon - medium - microsoft - orcid - patreon - pinterest - reddit - researchgate - slack - snapchat - soundcloud - stack-overflow - steam - telegram - tiktok - tumblr - twitch - twitter - x-twitter - whatsapp - youtube - ko-fi 创建作者分类 在配置文件config/_default/config.toml中找到taxonomies添加atuthor。这样文章将通过作者进行文章分类。 [taxonomies] tag = \u0026#34;tags\u0026#34; category = \u0026#34;categories\u0026#34; author = \u0026#34;authors\u0026#34; 配置多名作者菜单 编辑菜单文件config/_default/menus.语言代码.toml 配置到哪都行，主要是pageRef参数必须是authors，这样就方便通过作者找到对应的文章。 我这里习惯配置到页脚。 [[footer]] name = \u0026#34;©小橘子Single\u0026#34; pageRef = \u0026#34;authors\u0026#34; weight = 10 还可以向每个作者页面添加更多详细信息，以便它显示一些个人简介、链接或任何信息。\nmkdir -p content/authors/作者名称 touch content/authors/作者名称/_index.md # 文件内容 --- title: \u0026#34;authors\u0026#34; --- my name is authors 文章前置中引用作者信息 --- authors: - \u0026#34;小橘子Single\u0026#34; showAuthor: false # 是否显示默认作者 showAuthorsBadges : false # 是否在文章封面显示作者信息 --- 样本 下面的示例显示了默认网站作者已开启且文章有多个作者的示例。 SFTP 配置 165 字\u0026middot; loading \u0026middot; loading 小橘子Single sftp SFTP是基于SSH（Secure Shell）的协议，用于在客户端和服务器之间进行安全的文件传输。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/authors/","section":"知识存档","summary":"网站主题多个作者配置教程","title":"Blowfish主题设置多名作者","type":"docs"},{"content":" 声明冲突：同一个样式，多次应用到同一个元素。 层叠：解决声明冲突的过程，浏览器自动处理。(权重计算)\n比较重要性 重要性从高到低：\n作者样式表中的 !important 样式 作者样式表：开发者书写的样式 作者样式表中的普通样式 浏览器默认样式表中的样式。 比较特殊性 总体规划：看选择器，选择器选中的范围越小，越特殊 具体规则：通过选择器，计算出一个4位数（xxxx） 千位：如果是内联样式，记1，否则记0 百位：等于选择器中所有ID选择器的数量。 十位：等于选择器中所有类选择器、属性选择器、伪类选择器的数量。 个位：等于选择器中所有元素选择器，伪元素选择器的数量。 元素选择器、伪类选择器\u0026gt;类选择器class、属性选择器、伪类选择器\u0026gt;id选择器\u0026gt;元素内联样式\n案例1 \u0026lt;style\u0026gt; a { /* color: red !important; */ color: red; text-decoration: none; font-style: italic; } #mylink { /* 没有内联: 0 id：1 类|属性|伪类：0 元素：0 */ /* 0100 书写靠后则应用靠后的样式 */ color: #000; } #id { /* 0100 */ color: aqua; } .selected { color: #fff; background-color: red; } .active { /* 0010 */ color: blue; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Lorem.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Tempora?\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; \u0026gt;Beatae.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; id=\u0026#34;mylink\u0026#34; class=\u0026#34;selected\u0026#34; style=\u0026#34;color: chocolate;\u0026#34;\u0026gt;Quam.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34; id=\u0026#34;id\u0026#34; class=\u0026#34;active\u0026#34;\u0026gt;Doloribus.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Fugiat!\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Molestiae.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Est.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Animi.\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;\u0026#34;\u0026gt;Quidem.\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; 案例2 \u0026lt;style\u0026gt; a { /* 没有内联：0 没有ID：0 没有类，属性，伪类：0 1个元素：a */ /* 0001 */ color: red; } div ul a { /* 没有内联：0 没有ID：0 没有类，属性，伪类：0 3个元素：div ul a */ /* 所以是 0003 */ color: aqua; } #mydiv #myul a{ /* 0201 */ /* 没有内联：0 */ color: blueviolet; } #mydiv #myul .mylink { /* 没有内联：0 两个ID：2 1个类：.mylink 没有元素也没有伪元素：0 */ /* 所以是 0210 */ color: green; } #mydiv #myul a:link { /* 没有内联：0 两个ID：2 1个伪类 :link 1个元素 a */ /* 所以是 0211 */ color: chocolate; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;mydiv\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;myul\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;myli\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://163.com\u0026#34; class=\u0026#34;mylink\u0026#34;\u0026gt;举个例子\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 比较源次序 代码书写靠后的胜出。 应用 重置样式表 重置样式表：书写一些作者样式，覆盖浏览器的默认样式。 重置样式表 -》 浏览器的默认样式 常见的重置样式表：normalize.css、 reset.css、 meyer.css 重置样式表reset.css /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ dy, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: \u0026#39;\u0026#39;; content: none; } table { border-collapse: collapse; border-spacing: 0; } 爱恨法则 link \u0026gt; visited \u0026gt; hover \u0026gt; active\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day04/","section":"知识存档","summary":"解决声明冲突的原理讲解","title":"4.层叠","type":"docs"},{"content":" 正则表达式语法 本文的正则表达式语法适用于Nginx服务器的配置。 特殊字符 说明 * 0次或多次匹配前面的字符或子表达式。等效于{0,} zo* 与 z 和zoo匹配。 + 1次或多次匹配前面的字符或子表达式。等效于{1,} zo+ 与 zo 和 zoo匹配，与z不匹配。 ? 0次或1次匹配前面的字符串或子表达式。等效于{0,1} 该字符串紧随任何其他限定符(*、+、?、{n})、{n,}、{n,m})之后时，匹配模式是非贪婪的。非贪婪模式匹配搜索到的、尽可能少的字符串，而默认的贪婪模式匹配搜索到的、尽可能多的字符串。\nzo? 与z 和 zo匹配，但与 zoo 不匹配；o+?只与oooo中的单个o匹配，而o+与所有o匹配。do(es)? 与 do 或 does中的 do 匹配 ^ 匹配搜索字符串开始的位置。如果标志中包括m(多行搜索)字符，还将匹配\\n或\\r后面的位置。\n如果将^用作括号表达式中的第一个字符，则会对字符集求反。\n^\\d{3}与搜素字符串开始处的3个数字匹配。[^abc]与除a、 b、 c以外的任何字符匹配。 $ 匹配搜索字符串结尾的位置。如果标志中包含m(多行搜索)字符，还将匹配\\n或\\r前面的位置。\n\\d{3}$ 与搜索字符串结尾处的3个数字匹配。 . 匹配除换行符\\n 之外的任何单个字符。若要匹配包括\\n在内的任意字符，请使用诸如[\\s\\S]之类的模式。 [] 标记括号表达式的开始和结尾。\n[1-4]与1、2、3、4匹配。[^aAeEiIoOuU] 与任何非云隐字符匹配。 {} 标记限定符表达式的开始和结尾。\na{2,3} 与aa 和aaa 匹配。 () 标记子表达式的开始和结尾。Nginx 服务器使用该元字符保存子表达式以备将来之用。 A(\\d) 与A0 至A9匹配。保存该数字以备将来之用。 | 指示在两个或多个项之间进行选择。\n`z / 表示JScript中的文本正则表达式模式的开始或结尾。在第二个/后添加单字符标志可以指定搜索行为。 /abc/gi 是与abc 匹配的JScript文本正则表达式。g(全局)标志指定查找模式的所有匹配项，还可以使用i，表示忽略大小写，使搜索不区分大小写。 \\b 与一个字边界匹配;即字与空格间的位置。\ner\\b 与 nerver 中的er匹配。但与 verb中的 er不匹配。 \\B 非边界字匹配。 er\\B与 verb中的 er匹配。但与 nerver中的 er不匹配。 \\d 数字字符匹配。等效于[0-9] 在搜索字符串12345中，\\d{2}与12和34匹配。\\d与1、2、 3、 4、5匹配。 \\D 非数字字符匹配。等效于[^0-9]。 \\D+与abc123 def中的abc 和 def匹配。 \\w 与以下任意字符匹配: A-Z、a-z 、0-9和下划线。等效于[A-Za-z0-9_]。\n在字符串The quick brown fox...中，\\w+与The、 quick、 brown 、fox匹配。 \\W 与除A-Z、a-z 、0-9和下划线以外的任意字符匹配。等效于[^A-Za-z0-9_]。\n在字符串The quick brown fox...中，\\W+ 与...和所有空格匹配。 [xyz] 字符集。与任何一个指定字符匹配。 [abc], 与 plain中的a匹配。 [^xyz] 反向字符集。与未指定的任何字符匹配。\n[^abc], 与 plain中的p 、l、 i、 n匹配。 [a-z] 字符范围。匹配指定范围内的任何字符。\n[a-j]，与a 到 j范围内的任何小写字母符匹配。[E-Q], 与E到Q范围内的任何大写字母符匹配。 [^a-z] 反向字符范围。与不在指定范围内的任何字符匹配。\n[^a-j]，与不在范围a 到 j内的任何字符匹配。[^E-Q]，与不在E到Q范围内的任何大写字母符匹配。 {n} 正好匹配n次。n是非负整数。\no{2} 与Bob中的 o不匹配，但与 food中的2个 0匹配。 {n,} 至少匹配n次。n是非负整数。\n* 与{0,}相等; + 与 {1,}相等。 {n,m} 匹配至少n次，至多m次。m和n是非负整数，其中n\u0026lt;=m。逗号和数字之间不能有空格。\n?与 {0,1}相等。在搜索字符串1234567中，\\d{1,3}与123、 456、 7匹配。 (pattern) 与pattern匹配并保存匹配项。在Nginx服务器的配置文件中，可以通过该方法从匹配的字符串中返回检索的匹配项，以数组元素形式保存。若要匹配括号字符()，请使用转义字符\\( 或者 \\) `(Chapter (?:pattern) 与pattern匹配，但不保存匹配项；即不会存储匹配项以备将来之用。这对于用or字符` (?=pattern) 积极的预测先行。找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。不会保存匹配项以备将来之用。\n^(?=.*\\d).{4,8}$，匹配长度介于4到8个字符之间，并且必须至少包含一个数字的字符串。在该模式中，.*\\d 查找后跟有数字的任意多个字符。对于搜索字符串abc3qr,这与abc3匹配。从该匹配项之前 (而不是之后) 开始；{4,8}与包含4-8个字符的字符串匹配。这与abc3qr匹配。这个正则表达式可以用于判定密码的复杂度。 (?!pattern) 消极的预测先行。匹配与pattern不匹配的搜索字符串。找到一个匹配项后，将在匹配文本之前开始搜索下一个匹配项。不会保存匹配项以备将来之用。\n\\b(?!th)\\w+\\b 与不与 th开头的单词匹配。该模式中，\\b与一个字边界匹配。对于搜索字符串quick,这与第一个空格匹配。(?!th)与非th字符串匹配。这与qu匹配。从该匹配项开始，\\w+ 与一个字匹配。这与quick匹配。 ^和$ 指定搜索字符串的开始和结束位置。这将在搜索字符串包含匹配字符之外的任何字符是阻止匹配。 \\cx 匹配x指示的控制字符。x的值必须在A-Z或a-z范围内。如果不是这样，则假定c就是文本c字符本身。 \\cM 与Ctrl+M或一个回车符匹配。 \\xn 匹配n,此处的n是一个16进制转义码。16进制转义码必须正好是两位数长。允许在正则表达式中使用ASCII代码。\n\\x41与 A匹配。 \\x041等效于后跟有 1的 \\x04 (因为n必须正好是两位数)。 \\nm 匹配num，此处的num是一个正整数。这是对已保存的匹配项的引用。\n(.)\\1 与2个连续的相同字符匹配。 \\n 标识一个8进制转义码或反向引用。如果\\n 前面至少有n个捕获子表达式，则 n是反向引用。否则，如果 n是8进制数 (0-7)，那么 n是8进制转义码。\n(\\d)\\1 与两个连续的相同数字匹配。 \\nm 标识一个8进制转义码或反向引用。\n如果\\nm前面至少有 nm个捕获子表达式，那么 nm是反向引用。 如果\\nm前面至少有 n个捕获子表达式，则 n是反向引用，后面跟有文本 m。如果上述情况都不存在，当 n和 m是8进制数字 (0-7)时， \\nm匹配8进制转义码 nm。\n\\nml当 n是8进制数字 (0-3)， m和 l是8进制数字 (0-7)时，匹配8进制转义码 nml。 \\011 与制表符匹配。 \\un 匹配n，其中 n是以4位16进制数表示的 Unicode 字符。\n\\u00A9 与版权符号(©) 匹配。 \\f 换页符。等效于\\x0c 和 \\cL \\n 换行符。等效于\\x0a 和 \\cJ \\r 回车符。等效于\\x0d 和 \\cM \\t Tab 制表符。等效于\\x09 和 \\cI \\s 任何空白字符，包括空格、制表符和换页符。等效于[\\f\\n\\r\\t\\v] \\S 等效于任何非空白字符。等效于[^\\f\\n\\r\\t\\v] \\v 垂直制表符。等效于\\x0b 和 \\cK ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/regex/","section":"知识存档","summary":"正则表达式语法介绍","title":"Nginx Regex","type":"docs"},{"content":" 选择器: 帮助你精准的选中想要的元素\n简单选择器 ID选择器 -id对应的值: #id值{}\n#str{ color: red; } \u0026lt;p id=\u0026#34;str\u0026#34;\u0026gt;Lorem ipsum dolor sit amet.\u0026lt;/p\u0026gt; 元素选择器 元素: 元素{} p { color: blue; } \u0026lt;p\u0026gt;Lorem ipsum dolor sit amet.\u0026lt;/p\u0026gt; 类选择器 类对应的值: .class{} .left { background: coral; color: #fff; } \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;Lorem.\u0026lt;/div\u0026gt; 通配符选择器 *: 表示选中所有元素 *{} *{ color: red; } \u0026lt;div\u0026gt;Lorem.\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;Lorem.\u0026lt;/p\u0026gt; \u0026lt;h1\u0026gt;Lorem.\u0026lt;/h1\u0026gt; 属性选择器 匹配元素的属性: [属性=\u0026quot;\u0026quot;]{} [href=\u0026#34;https://www.baidu.com\u0026#34;]{ color: green; } \u0026lt;a href=\u0026#34;https://www.baidu.com\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; 伪类选择器: 选中某些元素的某种状态 必须要按照顺序进行排列。 爱恨法则：love hate link: 超链接未访问时的状态。 visited： 超链接访问过后的状态。 hover： 鼠标悬停状态。 active: 激活状态，鼠标按下状态。 a:link{ color: cadetblue; } a:visited{ color: fuchsia; } a:hover{ color: red; } a:active{ color: chocolate; } # a 表示要给a元素添加 伪元素选择器: 可以生成子元素 before after span::before{ /* 选中span元素会生成一个子元素，可以理解为生成一个before元素 */ content: \u0026#34;《\u0026#34;; /* 子元素中的内容 */ color: red; /* 颜色 */ } span::after{ content: \u0026#34;》\u0026#34;; color: red; } \u0026lt;p\u0026gt; 快来和我一起学习\u0026lt;span\u0026gt;HTML和CSS\u0026lt;/span\u0026gt;吧! \u0026lt;/p\u0026gt; 选择器的组合 并且 \u0026ndash; . 使用.链接元素和属性 p.red{ color: red; } \u0026lt;p\u0026gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maiores, facere velit. Nihil voluptates eum, earum ad dolor provident iure sit reprehenderit aliquid quis dolorem dolore veniam impedit quos explicabo id! \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;red\u0026#34;\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Adipisci quaerat minima, aspernatur natus eius nam debitis voluptates nesciunt possimus provident reprehenderit suscipit eaque quisquam consectetur illo quod vero molestias temporibus. \u0026lt;/p\u0026gt; 后代元素 \u0026ndash; 空格 使用空格连接父元素class属性和后代元素 .red li{ color: #008c8c; } \u0026lt;div class=\u0026#34;red\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Adipisci quaerat minima, aspernatur natus eius nam debitis voluptates nesciunt possimus provident reprehenderit suscipit eaque quisquam consectetur illo quod vero molestias temporibus. \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Earum!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Quas.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Nobis.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Accusamus.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ------------------------------------------------- .abc .bcd{ color: red; } \u0026lt;div class=\u0026#34;abc\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Lorem.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;bcd\u0026#34;\u0026gt;Nam.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Eius.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 子元素 \u0026ndash; \u0026gt; 使用\u0026gt;链接子元素 div\u0026gt;ul\u0026gt;li{ color: red; } div\u0026gt;ul li { color: red; } div li{ color: red; } \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Nisi!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;In!\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 相邻兄弟元素 \u0026ndash; + 使用+链接相邻的兄弟元素 .special{ color: red; } .special+li{ color: greenyellow; } \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consequuntur!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Officia.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Reiciendis!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Ipsum!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Tempore.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consequuntur?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Voluptatibus?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Totam?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Explicabo.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consequuntur!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Officia.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Reiciendis!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Ipsum!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Tempore.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Consequuntur?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Voluptatibus?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Totam?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Explicabo.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 兄弟元素 \u0026ndash; ~ 使用~链接兄弟元素 .special{ color: red; } .special~li{ color: aqua; } \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Minima.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Animi.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Modi.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Laudantium.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aliquam?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Eligendi.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Fuga.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Iusto.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Blanditiis!\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Labore?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Distinctio.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Libero!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Rerum.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Necessitatibus?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Magnam!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Quo.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Incidunt.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Rerum.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 选择器的并列 多个选择器,用逗号,分隔 .special{ color: red; } .special~li,p{ color: blueviolet; } \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Minima.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Animi.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Modi.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Laudantium.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Aliquam?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Eligendi.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Fuga.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Iusto.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Blanditiis!\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Lorem.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Labore?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Distinctio.\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;special\u0026#34;\u0026gt;Libero!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Rerum.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Necessitatibus?\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Magnam!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Quo.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Incidunt.\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Rerum.\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;Lorem ipsum dolor sit amet consectetur adipisicing.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Provident ullam voluptatem amet molestias cupiditate dolore?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Laboriosam eaque cum necessitatibus, iure explicabo hic.\u0026lt;/p\u0026gt; ","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day03/","section":"知识存档","summary":"选择器的用法案例","title":"3.选择器","type":"docs"},{"content":" Nginx 内置变量 Nginx服务器的配置文件中可以包含一些预设的变量，以帮助大家获取Nginx自身和网络等方面的信息供配置使用。以下记录了Nginx服务器中常用的内置变量，并对变量的含义做了相应的解释，供大家在使用中查询。\nnginx_variables 变量 说明 $arg_PARAMETER 客户端GET请求中PARAMETER字段的值 $args 客户端请求中的参数 $binary_remote_addr 远程地址的二进制表示 $body_bytes_sent 已发送的消息体字节数 $content_length HTTP请求信息里的Content-Type 字段 $cookie_COOKIE 客户端请求中COOKIE头域的值 $document_root 针对当前请求的根路径设置值 $document_uri 与$uri相同 $host 请求信息中的Host头域值，如果请求中没有Host行，则等于设置的服务器名 $http_HEADER HTTP请求信息里的HEADER字段 $http_host 与$host相同，但如果请求信息中没有Host行，则可能不同客户端的cookie信息 $http_cookie 客户端的cookie信息 $http_refere 引用地址 $http_user_agent 客户端代理信息 $http_via 最后一个访问服务器的IP地址 $http_x_forwarded_for 相当于网络访问路径 $is_args 如果$args有值，则等于\u0026quot;?\u0026quot;;否则等于空 $linit_rate 对链接速率的限制 $nginx_version 对当前Nginx服务器的版本 $pid 当前Nginx服务器主进程的进程ID $query_string 与$args相同 $remote_addr 客户端IP地址 $remote_port 客户端端口号 $remote_user 客户端用户名，用于 Auth Basic Module验证 $request 客户端请求 $request_body 客户端请求的报文体 $request_body_file 发往服务器的本地临时缓存文件的名称 $request_filename 当前请求的文件路径名，由root 或 alias 指令与URI请求生成 $request_method 请求的方法，比如GET、POST等 $request_uri 请求的URI，带参数，不包含主机名 $scheme 所用的协议，如http 或者https。比如：rewrite^(.+)$$scheme://mysite.name$1redirect $sent_http_cache_control 服务端发送客户端的Cache-Control响应头的值。 $sent_http_connection $sent_http_content_length $sent_http_content_type $sent_http_keep_alive $sent_http_last_modified $sent_http_location $sent_http_transfer_encoding $server_addr 服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(会造成资源浪费) $server_name 请求到达的服务名。 $server_port 请求到达的服务器端口号 $server_protocol 请求的协议版本，HTTP/1.0 或 HTTP/1.1 $uri 请求的不带请求参数的URI，可能和最初的值有不同，比如经过重定向之类的 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/var/","section":"知识存档","summary":"Nginx 常用的内置变量介绍","title":"Nginx Var","type":"docs"},{"content":" color（文字颜色） 元素内部的文字颜色. 预设值：定义好的单词 三原色，色值：光学三原色（红、绿、蓝），每个颜色可以0-255之间的数字来表达。\nrgb表示法: rgb(0,0,0) # rgb 表示法： color: rgb(0,255,0) ## rgb 代表红绿蓝，数值越大颜色越深。当三个数为0时，则黑色，当三个数为255时，则白色。 hex(16进制)表示法: #000000 可简写为: #000 #红绿蓝 color: #008c8c 淘宝红：#ff4400,#f40 黑色: #000000, #000 白色：#ffffff, #fff 红：#ff0000, #f00 绿：#00ff00, #0f0 蓝：#0000ff, #00f 紫：#ff00ff,#f0f 青：#00ffff,#0ff 黄：#ffff00,#ff0 灰色：#cccccc ,#ccc background-color（背景颜色） 元素背景颜色 font-size（字体大小） 元素内部文字的尺寸大小 px: 像素，简单的理解为文字的高度占多少个像素 em: 相对单位。相对于父元素的字体大小。3em,表示父元素字体大小的3倍像素。 每个元素必须有字体大小，如果没有声明，则直接使用父元素的字体大小，如果没有父元素（HTML），则使用基准字号。 基准字号可以从浏览器设置中查询。computed中查找font-zise。 user agent, UA, 用户代理（浏览器 有默认的样式）\nfont-weight（字体粗细） 文字粗细程度，可以取值数字，可以取值为预设值（单词） strong元素，默认加粗。表示重要、不可忽略的内容。 font-weight: bold # 加粗 700 font-weight: normal # 默认值 font-family（字体种类） 文字类型：字体类型，例如：宋体，微软雅黑 必须用户计算机中存在的字体才会有效果。 使用多个字体，以匹配不同环境的 sans-serif: 非衬线字体。字体的边缘没有修饰。通用字体，用于兼容老的计算机字体。 font-family: arial,console,宋体，微软雅黑,sans-seif font-style（字体倾斜） 字体样式，通常用它设置斜体 i 元素（影响语音阅读）：默认样式，是倾斜字体；实际使用中，通常用它表示一个图标（icon） em元素：表示强调的内容 font-style: italic text-decoration（文本修饰） 文本修饰，给文本加线。 del元素：错误的内容。 s元素：过期的内容。 text-decoration: line-through line-through：在字体中间穿过一条线。穿过文字 underline: 在字体下方加一条线。 overline: 在字体上方加一条线. none: 表示没有 text-indent（文本缩进） 首行文本缩进 px: 适用于英文 em: 适用于中文，2em 缩进2个字 line-height（行高） 每行文本的高度，该值越大，每行文本的距离越大。 设置行高为容器的高度可以让单行文本垂直居中。 行高设置为纯数字，表示相对于当前元素的字体大小。 \u0026lt;style\u0026gt; p { background: #008c8c; color: #fff; height: 50px; line-height: 50px; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit. \u0026lt;p\u0026gt; width（元素容器宽度） 宽度 px em height（元素容器高度） 高度 px em letter-space（文字间隙） 文字之间的间隙隙 px em text-align（文本排列方式） 元素内部文字的水平排列方式 left：水平靠左排列 center：水平居中排列 right：水平靠右排列 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day02/","section":"知识存档","summary":"常见的样式声明及用例","title":"2.常见的样式声明","type":"docs"},{"content":" 术语解释 css规则 = 选择器 + 声明块 \u0026lt;style\u0026gt; /* CSS规则 */ h1{ /* 选择器 */ color: red; /* 声明(属性) */ background-color: lightblue; /* 声明 */ text-align: center; /* 声明(属性) */ } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; 现在开始添加样式 \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; 选择器 选择器：选中元素 ID选择器：选中的是对应ID值的元素 #id值{} 元素选择器: div{} a{} h1{} p{} ... 类选择器 .class值{} \u0026lt;!-- 元素选择器 --\u0026gt; h1{ color: red; background-color: lightblue; text-align: center; } \u0026lt;!-- #ID选择器 --\u0026gt; #test{ color: blue; } \u0026lt;!-- 类选择器 --\u0026gt; .red{ color: red; } \u0026lt;!-- 类选择器 --\u0026gt; .big-center{ font-size: 3em; text-align: center; } \u0026lt;h1\u0026gt;这是1级标题\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;big-center red\u0026#34;\u0026gt; Lorem ipsum dolor sit amet. \u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;test\u0026#34;\u0026gt;Lorem ipsum dolor sit amet.\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;red\u0026#34;\u0026gt;Saepe odio cupiditate laborum a.\u0026lt;/p\u0026gt; 声明块 出现在大括号{}中. 声明块中包含很多声明（属性），每一个声明（属性）表达了某一方面的样式。 h1 { /* 声明块 */ color: red; background-color: lightblue; text-align: center; } css代码书写位置 内部样式表：书写在\u0026lt;style\u0026gt;元素中。放到\u0026lt;head\u0026gt;元素中告诉浏览器最先加载样式。 内联样式表，也叫元素样式表：直接书写在元素内。\u0026lt;h1 style=\u0026quot;color: red; font-size: 2em;\u0026quot;\u0026gt;内联样式\u0026lt;/h1\u0026gt; 外部样式表[推荐使用]：将样式书写到独立的CSS文件中。在\u0026lt;head\u0026gt;元素中使用\u0026lt;link\u0026gt;元素关联CSS文件的样式。 外部样式表可以解决多页面样式重复的问题。 有利于浏览器缓存，从而提高页面响应速度。 有利于代码分离（HTML 和 CSS），更容易阅读和维护。 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/index.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;red-big-center\u0026#34;\u0026gt; Lorem ipsum dolor sit amet. \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; CSS文件内容: css/index.css .red-big-center { color: blue; font-size: 5em; text-align: center; } ","date":"January 1, 1","externalUrl":"","permalink":"/docs/css/day01/","section":"知识存档","summary":"声明样式的应用","title":"1.为网页添加样式","type":"docs"},{"content":" timeline title 我在鹏城驾校的日子 section 2023年5月 7号: 报名鹏城驾校 11号: 学员认证 13号: 约考科目一条件通知 section 2023年6月 2号: 约考科目一 11号: 缴纳科目一考试费 17号: 科目一考试: 一次过 21号: 科目二练习通知 27号: 模拟器练习 section 2023年7月 1号: 模拟器练习 2号: 模拟器练习 3号: 模拟器练习 section 2024年3月 8号: 实车练习 16号: 实车练习 20号: 实车练习 30号: 实车练习 31号: 实车练习 section 2024年4月 1号: 实车练习 5号: 实车练习 6号: 实车练习 8号: 实车练习 12号: 实车练习 16号: 实车练习 17号: 实车练习 25号: 实车练习 section 2024年5月 12号: 刷1个半实车学时: 约考科目二 17号: 实车练习 18号: 实车练习 19号: 实车练习 21号: 实车练习 22号: 实车练习 23号: 考场模拟训练: 科目二考试: 2次过 ","date":"January 1, 1","externalUrl":"","permalink":"/about/pcjx/","section":"关于","summary":"mermaid 时间线","title":"mermaid","type":"about"},{"content":" 关于我 网名：小橘子Single 兴趣：追剧，摄影，打游戏(又菜又爱玩)，刷抖音，听音乐，睡懒觉。 影视: 韩剧，国产剧喜欢古装、悬疑、科幻、犯罪、穿越、热血、言情类，还有林正英的僵尸题材的剧。hhh,妥妥的追剧达人。2024年9月因为一个片段，彻底入坑泰剧。 摄影：拥有三台相机，一台富士XT20，一台理光GR3，一台富士拍立得mini90。目前还是摄影小白。 游戏：拥有一台Swith游戏机，有塞尔达传说- 旷野之息DLC和王国之泪，奥德赛，路易吉鬼屋3，马里奥赛车8，分手厨房2，宝可梦紫DLC。目前已通关旷野之息，王国之泪还在进行中。手游的话可能会玩卡牌类的，抖音小游戏砖了个砖，历史最高记录22层，这游戏费脑，每天数独。 运动：emm 不可能，绝对不可能。已经被床，沙发束缚了手脚。每天，除了工作时间就是各种葛优瘫。 喜欢的明星：lingorm 正在做的事：考驾照，练书法，折腾自己的网站，学习泰语，韩语，英语 (中文都没学明白，学外语\u0026hellip;..)。 学车经历 关于博客 创建到现在有3年了，期间经历了几次迁移。 使用Hugo搭建，托管在GitHub Pages上。 网站主题使用blowfiwsh，喜欢卡片式的布局方式。 初衷是建立一个网站，记录与分享。 ","date":"January 1, 1","externalUrl":"","permalink":"/about/me/","section":"关于","summary":"关于我的一些资料","title":"关于我","type":"about"},{"content":" 背景 最近使用MAC终端连接服务器，发现在终端上使用不了rz/rz命令，导致无法传输文件。因此想到了SFTP工具。 SFTP是基于SSH（Secure Shell）的协议，用于在客户端和服务器之间进行安全的文件传输。 SFTP本质上是一种命令行工具，它需要通过终端或者命令行界面与服务器进行交互。 完美解决 Mac系统终端文件与服务器文件传输问题。 1. 安装OpenSSH服务 可以检查下服务器是否安装有这个服务 rpm -q openssh-server 若没有安装，可使用下面命令安装 yum -y install openssh-server 2. 配置SSH服务 编辑SSH服务的配置文件：/etc/ssh/sshd_config 将内容添加到文件末尾。 vim /etc/ssh/ssh_config # 指定使用哪个子系统来处理SFTP连接。internal-sftp 是openssh提供的内部sftp子系统 Subsystem sftp internal-sftp # 配置传送目录和所属用户 Match Group sftpusers # 指定SFTP用户的根目录 %h 代表占位符，表示指定用户家目录，%u 代表占位符，表示指定用户名 ChrootDirectory /home/sftp/%u # 用于控制是否启用X11转发,X11转发是一种通过SSH连接远程主机并在本地显示图形界面应用程序的功能。 X11Forwarding no # 用于控制是否允许TCP端口转发,TCP端口转发是SSH协议中的一项功能，它允许通过SSH隧道在远程主机和本地主机之间转发TCP网络连接。 AllowTcpForwarding no # 强制执行指定的命令。当设置ForceCommand为internal-sftp时，表示强制使用内部的SFTP子系统处理所有SSH连接请求。 ForceCommand internal-sftp ---------------------------------------------------------------------------------------------------------- # 指定SSH端口,建议修改SSH默认端口 Port 2222 3. 创建SFTP用户组 groupadd sftpuser 4.创建SFTP管理目录 mkdir /home/sftpuser chmod 0755 /home/sftpuser 5. 创建SFTP用户 useradd -g sftpusers -d /home/sftp/\u0026lt;username\u0026gt; -p $(openssl passwd -1 \u0026#39;your passwd\u0026#39;) -s /sbin/nologin \u0026lt;username\u0026gt; # -g 指定用户组 # -d 指定用户主目录 # -p 设置用户加密密码 # 使用 openssl passwd -1 生成一个基于MD5加密的密码 6. 设置SFTP用户主目录的权限 权限直接影响SFTP用户连接后的权限 chown root:sftpuser /home/sftp/\u0026lt;username\u0026gt; chmod 0755 /home/sftp/\u0026lt;username\u0026gt; 设置一个可以操作的子目录 mkdir /home/sftp/\u0026lt;username\u0026gt;/putfile chmod 0700 /home/sftp/\u0026lt;username\u0026gt;/putfile chown \u0026lt;username\u0026gt;:sftp /home/sftp/\u0026lt;username\u0026gt;/putfile 当然啦，你可以不用像我这样操作，目录可以换成其他的。\n7. 重启SSH服务 systemctl restart sshd 8. 测试验证 Mac连接SFTP服务 sftp -oPort=2222 \u0026lt;username\u0026gt;@host # -o: 指定服务器端口号，若修改了端口号需要这个选项。 # username: 服务器中创建的sftp用户 # host: 主机名称或IP地址。 连接成功后使用ls命令查看当前目录的文件，能看到文件就代表连接成功。\nMac下载文件不指定路径的话，默认下载路径为你当前账号登录Mac系统的路径。\nsftp 常用命令 ls: 显示远程目录列表 pwd: 显示远程当前所在目录 put: 上传文件。put 本机路径 远程路径 get: 下载文件。get 远程路径 本机路径 bye/quit: 退出sftp cp: 复制远程文件 mkdir: 创建远程目录 rmdir: 删除远程目录 rm: 删除远程文件 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/linux/sftp/","section":"知识存档","summary":"SFTP是基于SSH（Secure Shell）的协议，用于在客户端和服务器之间进行安全的文件传输。","title":"SFTP 配置","type":"docs"},{"content":" Nginx 服务器架构初探 模块化结构的相关知识 Nginx 如何处理服务 Nginx 如何处理Web请求 Nginx 的事件驱动模型 Nginx 涉及架构的概览 模块化结构 什么是\u0026quot;模块化设计呢?\u0026quot; 在计算机领域，针对程序设计，常见的说法是把\u0026quot;模块化设计\u0026quot;定义为\u0026quot;以功能块为单位进行程序设计，实现其秋节算法的方法\u0026quot;。\n第①：\u0026ldquo;功能块\u0026quot;是对模块的描述，一个模块就是一个功能块，应该只负责一个功能，在设计模式理论中类似于经常提到的\u0026quot;单一职责原则\u0026rdquo;。\n第②：如果要体现模块化，就免不了将程序进行分解，这也是模块化编程的另一个原则\u0026ndash;自顶向下，逐步求精原则。\n第③：一个程序被分解为多个模块，那么它们之间一定要存在一定的依赖关系，但是这个依赖不能太强，否则也就不能称之为\u0026quot;模块化\u0026quot;了。于是，又涉及到模块化编程的一条原则：高内聚，低耦合原理。事实上，在设计模式理论中，也有对应的一条设计原理叫\u0026quot;迪米特原则\u0026quot;。\n这个提法把\u0026quot;模块化编程\u0026quot;定义为程序设计的一种方法，这种方法的结果是用一系列以功能为单位的算法来描述和实现程序。\n模块化设计支持分布式开发。模块化的思想导致大量功能独立的的模块出现，这些模块可以分布在世界上的任何角落。无论是开发中小型的应用程序，还是构建大型的诸如操作系统之类的程序，都可以采用分布式开发模型，集合任何可用模块为己所用。\n模块化设计支持团队协同合作。在采用模块化思想进行程序设计时，最终的产品由小的、分散的功能块组成，每一块都是基本独立的。这些功能块可以由不同的团队根据他们自己的时间表和生命周期进行开发，互不影响。最终的产品则可以由另一个独立的个体\u0026ndash;发行者进行集成。\n模块化设计支持应用扩展和升级。应用模块化思想设计出来的程序，就如同用积木搭起来的房子。各个模块之间既能保持自己的独立性，也能通过接口保持联系。在对应用扩展时，只要实现规范的接口，就可以不断加入新功能；在对其中某些模块进行升级时，只要保持原有接口不变，就能够在不影响其他模块的前提下进行。\nNginx 模块化结构 核心模块 标准HTTP模块 可选HTTP模块 邮件服务模块 第三方模块 核心模块是指Nginx服务器正常运行必不可少的模块，它们提供了Nginx最基本最核心的服务，如进程管理，权限控制，错误日志记录等。\n标准HTTP模块支持Nginx服务器的标准HTTP功能。\n可选HTTP模块主要用于扩展标准的HTTP功能，使其能够处理一些特殊的HTTP请求；\n邮件服务模块主要用于支持Nginx的邮件服务。\n第三方模块使为了扩展Nginx服务器应用，完成特殊功能而由第三方机构或者个人编写的可编译到Nginx中的模块。\n核心模块 核心模块主要包含对两类功能的支持，一类是主体功能，包括进行管理、权限控制、错误日志记录、配置解析等，另一类是用于响应请求事件必需的功能，包括事件驱动机制、正则表达式解析等。\n标准HTTP模块 提供基本HTTP服务，常用标准HTTP模块见下表。 这些模块在默认情况下是被编译到Nginx中。 模块 功能 ngx_http_core 配置端口、URI分析、服务器响应错误处理、别名控制以及其他HTTP核心事务 ngx_http_access_module 基于IP地址的访问控制(允许/拒绝) ngx_http_auth_basic_module 基于HTTP的身份认证 ngx_http_autoindex_module 处理以/结尾的请求并自动生成目录列表 ngx_http_browser_module 解析HTTP请求头中的User_Agent域的值 ngx_http_charset_module 指定网页编码 ngx_http_empty_gif_module 从内存创建一个1 X 1的透明GIF图片，可以快速调用 ngx_http_fastcgi_module 对FastCGI的支持 ngx_http_geo_module 将客户端请求中的参数转化为键值对变量 ngx_http_gzip_module 压缩请求响应，可以减少数据传输 ngx_http_header_filter_module 设置HTTP响应头 ngx_http_index_module 处理以/结尾的请求，如果没有找到该目录下的index页，就将请求转给ngix_http_autoindex_module模块处理；如果Nginx服务器开启了ngx_http_random_index_modeule模块，则随机选择index页 ngx_http_limit_req_module 限制来自客户端的请求的响应和处理速率 ngx_http_limit_conn_modeule 限制来自客户端的连接的响应和处理速率 ngx_http_log_module 自定义access日志 ngx_http_map_module 创建任意键值对变量 ngx_http_memcached_module 对memcached的支持 ngx_http_proxy_module 支持代理服务 ngx_http_referer_module 过滤HTTP头中Referer域值为空的HTTP请求 ngx_http_rewrite_module 通过正则表达式重定向请求 ngx_http_scgi_module 对SCGI的支持 ngx_http_ssl_module 对HTTPS的支持 ngx_http_upstream_module 定义一组服务器，可以接收来自代理、fastcgi、memcached的重定向，主要用于负载均衡 可选HTTP模块 可选HTTP模块在目前的Nginx发行版中只提供源代码，但在快俗编译时默认不编译。如果想使用相关模块，就必须在配置时使用--with-XXX参数声明。 常用可选HTTP模块见下表。 模块 功能 ngx_http_addition_module 在响应请求的页面开始或者结尾添加文本信息 ngx_http_degradation_module 在低内存的情形下允许Nginx服务器返回444错误或者204错误 ngx_http_perl_module 在Nginx 的配置文件中可以使用Perl脚本 ngx_http_flv_module 支持将Flash多媒体信息按照流文件传输，可以根据客户端指定的开始位置返回Flash ngx_http_geoip_module 支持解析基于 GeoIP 数据库的客户端请求(关于GEOIP数据库的细节请查看 GEOIP官方网站) ngx_google_perftools_module 支持Google Performance Tools(是Google公司开发的一套用于C++Profile的工具集，细节请查看其 官方网站) ngx_http_gzip_module 支持在线实时压缩响应客户端的输出数据流 ngx_http_gzip_static_module 搜索并使用预压缩的以.gz为后缀名的文件替代一般文件响应客户端请求 ngx_http_image_filter_module 支持改变JPEG、GIF 和 PNG 图片的尺寸和旋转方向 ngx_http_mp4_module 支持将H.264/AAC编码的多媒体信息(后缀名通常为 mp4、m4v 或 m4a)按照流文件传输，常与ngx_http_flv_modeule模块一起使用 ngx_http_random_index_module Nginx接收到以/结尾的请求时，在对应的目录下随机选择一个文件作为index文件。 ngx_http_secure_link_module 支持对请求链接的有效性检查 ngx_http_ssl_module 对HTTPS/SSL的支持 ngx_http_stub_status_module 支持返回Nginx服务器的统计信息，一般包括处理连接请求的数量、连接成功的数量、处理的请求数、读取和返回的Header信息数等信息 ngx_http_sub_module 使用指定的字符串替换响应信息中的信息 ngx_http_dav_moduel 支持HTTP协议和webDAV协议中PUT、DELETE、MKCOL、COPY和MOVE方法 ngx_http_xslt_module 将XML响应信息使用XSLT(扩展样式表转换语言) 进行转换 邮件服务模块 邮件服务是Nginx服务器提供的主要服务之一。和Nginx服务器提供的邮件服务相关的模块见下表。 模块 功能 ngx_mail_core_module 提供了Nginx邮件程序的核心功能 ngx_mail_pop3_module 对邮件POP3协议的支持 ngx_mail_imap_module 对邮件IMAP协议的支持 ngx_mail_smtp_module 对邮件SMTP协议的支持 ngx_mail_auth_http_module 基于邮件的身份认证 ngx_mail_proxy_module 支持邮件代理服务 ngx_mail_ssl_module 对邮件支持 HTTPS/SSL 协议 第三方模块 由于Nginx支持自定义模块编程，第三方模块不断得到扩充，功能页非常丰富。 在第三方模块的开发者中，深受广大Nginx用户推崇的要算是以为笔名为agentzh的工程师了。他开发的echo-nginx-module模块(支持在Nginx配置文件中使用echo、sleep、time、及exec等类Shell命令)、memc-nginx-momdule模块(对标准HTTP模块ngx_http_memcached_module的扩展，支持set、add、delete等更多的命令)、rds-json-nginx-module模块(使nginx支持json数据的处理)、lua-nginx-module模块(使nginx支持lua脚本语言)等。 Nginx服务器的Web请求处理机制 从涉及架构上来说，Nginx服务器是与众不同的。一方面体现在他的模块化涉及，另一方面体现在它对客户端请求的处理机制上。 Web服务器和客户端是一对多的关系，Web服务器必须有能力同时为多个客户端提供服务。一般来说，完成并行处理请求工作有三种方式可提供选择：多进程方式、多线程方式和异步方式。 多进程方式 多进程方式是指，服务器每当接收到一个客户端时，就由服务器主进程生成一个子进程出来和该客户端建立连接并进行交互，直到连接断开，该子进程就结束了。\n多进程方式的优点在于，涉及和实现相对简单，各个子进程之间相互独立，处理客户端请求的过程彼此不受到干扰，并且当一个子进程产生问题时，不容易将影响漫延到其他进程中，这保证了提供服务的稳定性。当子线程退出时，其占用资源会被系统操作回收，也不会留下任何垃圾。\n缺点是，操作系统中生成一个子进程需要进行内存复制等操作，在资源和时间上回产生一定的额外开销，因此，如果Web服务器接收大量并发请求，就会对系统资源造成压力，导致系统性能下降。\n初期的Apache服务器就是采用这种方式对外提供服务的。为了应对大量并发请求，Apache服务器采用\u0026quot;预生成进程\u0026quot;的机制对多进程方式进行了改进。\u0026ldquo;预生成进程\u0026quot;的工作方式很好理解，它将生成子进程的时机提前，在客户端请求还没有到来之前就预先生成好，当请求到来时，主进程分配一个子进程和该客户端进行交互，交互完成之后，该进程也不结束，而被主进程管理起来等待下一个客户端请求的到来。改进的多进程方式在一定程度上缓解了大量并发请求情形下Web服务器对系统资源造成的压力。但是由于Apache 服务器在最初的架构设计上采用了多进程方式，因此这不能从根本上解决问题。\n多线程方式 多线程方式和多进程方式相似，它是指，服务器每当接收到一个客户端时，会由服务器主进程派生出一个线程出来和该客户端进行交互。\n由于操作系统产生一个线程的开销远远小于产生一个进程的开销，所以多线程方式在很大程度上减轻了Web服务器对系统资源的要求。该方式使用线程进行任务调度，开发方面可以遵循一定的标准，这相对来说比较规范和有利于协作。但在线程管理方面，该方式有一定的不足。多个线程位于同一个进程内，可以访问同样的内存空间，彼此之间相互影响；同时，在开发过程中不可避免地要由开发者自己对内存进行管理，其增加了出错的风险。服务器系统需要长时间连续不停地运转，错误的逐渐积累可能最终对整个服务器产生重大影响。\nIIS 服务器使用了多线程方式对外提供服务，它的稳定性相对来说还是不错的，但对于经验丰富的Web服务器管理人员而言，他们通常还是会定期检查和重启服务器，以预防不可预料的故障发生。\n异步方式 异步方式是和多进程方式以及多线程方式完全不同的一种处理客户端请求的方式。\n网络通信中的同步机制和异步机制是描述通信模式的概念。同步机制，是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步机制，和同步机制正好相反，在异步机制中，发送方发出一个请求后，不用等待接收方响应这个请求，就继续发送下一个请求。在同步机制中，所有的请求在服务器端得到同步，发送方和接收方对请求的处理步调是一致的；在异步机制中，所有来自发送方的请求形成一个队列，接收方处理完成后通知发送方。\n阻塞和非阻塞用来描述进程处理调用的方式，在网络通信中，主要指网络套接字socket 的阻塞和非阻塞的方式，而socket 的实质也就是IO操作。socket的阻塞调用方式为，调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行；socket的非阻塞调用方式和阻塞调用方式正好相反，在非阻塞调用方式中，如果调用结果不能马上返回，当前线程也不会被挂起，而是立即返回执行下一个调用。 在网络通信中，经常可以看到有人将同步和阻塞等同，异步和非阻塞等同。事实上，这两对概念有一定的区别，不能混淆。两对概念的组合，就会产生出四个新的概念：同步阻塞、异步阻塞、同步非阻塞、异步非阻塞。\n同步阻塞方式 发送方向接收方发送请求后，一直等待响应；接收方处理请求时进行的IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。例如：在超时排队付账时，客户(发送方)向收款员(接收方) 付款(发送请求) 后需要等待收款员找零，期间不能做其他的事情；而收款员要等待收款机返回结果(IO操作)后才能把零钱取出来交给客户(响应请求)，期间也只能等待，不能做其他事情。这种方式实现简单，但是效率不高。 同步非阻塞方式 发送方向接收方发送请求后，一直等待响应；接收方处理请求时进行的IO操作如果不能马上得到结果，就立即返回，去做其他的事情，但由于没有得到请求处理结果，不响应发送方，发送方一直等待。一直到IO操作完成后，接收方获得结果响应发送方后，接收方才进入下一次请求过程。在实际中不适用这种方式。 异步阻塞方式 发送方向接收方发送请求后，不用等待响应，可以接着进行其他工作；接收方处理请求时进行的IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。这种方式在实际中也不使用。 异步非阻塞方式 发送方向接收方发送请求后，不用等待响应，可以继续其他工作；接收方处理请求时进行的IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。例如： 客户(发送方) 向收款员(接收方) 付款(发送请求) 后在等待收款员找零的过程中，还可以做其他事情，比如打电话、聊天等；当收款机产生结果后，收款员给客户结账(响应请求)。在四种方式中，这种方式是发送方和接收方通信效率最高的一种。 Nginx 服务器如何处理请求 Nginx 服务器的一个显著优势是能够同时处理大量并发请求。它结合多进程机制和异步机制对外提供服务。异步机制使用的是异步非阻塞方式。Nginx服务器启动后，可以产生一个主进程(master process) 和多个工作进程(worker process)，其中可以在配置文件中指定产生的工作进程数量。Nginx服务器的所有工作进程都用于接收和处理客户端的请求。这类似于Apache使用的改进的多进程机制，预先生成多个工作进程，等待处理客户端请求。\n注意： 实际上，Nginx服务器的进程模型有两种，Single模型和Master-Worker模型。Single模型为单进程方式，性能较差，一般在实际工作中不使用。Master-Worker模型实际上被广泛地称为Master-Slave模型。在Nginx服务器中，充当Slave角色的是工作进程。\n每个工作进程使用了异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；而客户端在此期间也无需等待响应，可以去处理其他的事情；当IO调用返回结果时，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事务，去响应客户端请求。\n客户端请求数量增长、网络负载繁重时，Nginx服务器使用多进程机制能够保证不增长对系统资源的压力；同时使用异步非阻塞方式减少了工作进程在I/O调用上的阻塞延迟，保证了不降低对请求的处理能力。\nNginx 服务器的事件处理机制 Nginx 服务器的工作进程调用IO后，就去进行其他工作了，当IO调用返回后，会通知工作进程。这里有一个问题，IO调用时如何把自己的状态通知给工作进程的呢？\n一般解决这个问题的方案有两种。一是，让工作进程在进行其他工作的过程中间隔一段时间就去检查一下IO的运行状态，如果完成，就去响应客户端，如果未完成，就继续正在进行的工作；二是，IO调用在完成后能主动通知工作进程。对于前者，虽然工作进程在进行其他工作的过程中没有等待，但不断的检查仍然在时间和资源上导致了不小的开销，最理想的解决方案是第二种。\n具体来说，select/poll/kqueue 等这样的的系统调用就是用来支持第二种解决方案的。这些系统调用，也常被称为事件驱动模型，它们提供了一种机制，让进程可以同时处理多个并发请求 ，不用关心IO调用的具体状态。IO调用完全由事件驱动模型来管理，事件准备好之后就通知工作进程事件已经准备就绪。\nNginx 服务器的事件驱动模型 事件驱动模型是Nginx 服务器保障完整功能和具有良好性能的重要机制之一。 事件驱动模型概述 事实上，事件驱动并不是计算机编程领域的专业词汇，它是一种比较古老的响应事件的模型，在计算机编程、公共关系、经济活动等领域均有很广泛的应用。顾名思义，事件驱动就是在持续事务管理过程中，由当前时间点上出现的事件引发的调动可用资源执行相关任务，解决不断出现的问题，防止食物堆积的一种策略。在计算机领域，事件驱动模型对应一种程序设计方式，Event-drivenprogramming，即事件驱动程序设计。\n事件驱动模型 如图所示，事件驱动模型一般是由时间收集器、事件发送器和事件处理器三部分基本单元组成。\n其中，事件收集器专门负责收集所有事件，包括来自用户的(鼠标点击、键盘输入事件等)、来自硬件的(如时钟事件等)和来自软件的(如操作系统、应用程序本身等)。事件发送器负责将收集到的事件分发到目标对象中。目标对象就是事件处理器所处的位置。事件处理器主要负责具体事件的响应工作，它往往要到实现阶段才完全确定。\n在程序设计过程中，对事件驱动机制的实现方式有多种，这里介绍 batch programming，即批次程序设计。批次的程序设计是一种比较初级的程序设计方式。使用批次程序设计的软件，其流程是由程序设计师在设计编码过程中决定的，也就是说，在程序运行的过程中，事件的发生、事件的发送和事件的处理都是预先设计好的。由此可见、事件驱动程序设计更多的关注了事件产生的随机性，使得应用程序能够具备相当的柔性，可以应付种种来自用户、硬件和系统的离散随机事件，这在很大程度上增强了用户和软件的交互性和用户操作的灵活性。\n事件驱动程序可以由任何编程语言来实现，只是难易程度有别。如果一个系统是以事件驱动程序模型作为编程基础的，那么，它的架构基本上是这样的：预先设计一个事件循环所形成的程序，这个事件循环构成了如上图所示的\u0026quot;事件收集器\u0026rdquo;，它不断地检查目前要处理的事件信息，然后使用\u0026quot;事件发送器\u0026quot;传递给\u0026quot;事件处理器\u0026quot;。\u0026ldquo;事件处理器\u0026rdquo; 一般运用虚函数机制来实现。\n我们日常使用的Windows操作系统，就是基于事件驱动程序设计的典型实例。Windows操作系统中的视图(通常叫做\u0026quot;窗口\u0026quot;)，是我们所说的事件发送器的目标对象。视图接收事件并能够对其进行相应的处理。当我们将事件发送到具体的某一个视图的时候，实际上我们完成了从传统的流线型程序结构到事件触发方式的转变。\nNginx 中的事件驱动模型 Nginx 服务器响应和处理Web请求的过程，就是基于事件驱动模型的，它也包含事件收集器、事件发送器和事件处理器等三部分基本单元。那么，Nginx 服务器是如何使用事件驱动模型来工作的呢？ \u0026ldquo;目标对象\u0026quot;中的\u0026quot;事件处理\u0026quot;可以有以下几种实现办法：\n\u0026ldquo;事件发送器\u0026rdquo;：每传递过来一个请求，\u0026ldquo;目标对象\u0026quot;就创建一个新的进程，调用\u0026quot;事件处理器\u0026quot;来处理该请求。\n\u0026ldquo;事件发送器\u0026rdquo;：每传递过来一个请求，\u0026ldquo;目标对象\u0026quot;就创建一个新的线程，调用\u0026quot;事件处理器\u0026quot;来处理该请求。\n\u0026ldquo;事件发送器\u0026rdquo;：每传递过来一个请求，\u0026ldquo;目标对象\u0026quot;就将其放入到一个待处理事件的列表，使用非阻塞I/O方式调用\u0026quot;事件处理器\u0026quot;来处理该请求。\n上面三种处理方式，各有特点，第一种方式，由于创建新的进程的开销比较大，会导致服务器性能比较差，但实现相对简单；第二种方式，由于要涉及到线程的同步，故可能会面临死锁、同步等一系列问题，编码比较复杂；第三种方式，在编写程序代码时，逻辑比前面两种都复杂。大多数网络服务器都采用了第三种方式，逐渐形成了所谓的\u0026quot;事件驱动处理库\u0026quot;。\n事件驱动处理库又被称为多路IO复用方法，最常见的包括以下三种：select模型、poll模型、epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型。通过Nginx配置可以使得Nginx服务器支持这几种事件驱动处理模型。\nselect 库 select库，是各个版本的Linux和Windows平台都支持的基本事件驱动模型库，并且在接口的定义上也基本相同，只是部分参数的含义略有差异。使用select库的步骤一般是: 首先，创建所关注的事件的描述符集合。对于一个描述符，可以关注其上面的读(read)事件、写(write)事件以及异常发生(exception)事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。\n其次，调用底层提供的select()函数，等待事件发生。这里需要注意的一点是，select 的阻塞与是否设置非阻塞I/O是没有关系的。\n然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有相应的事件发生，如果有，就进行处理。\nNginx 服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。我们可以使用--with-select_module 和--without-select_module两个参数强制Nginx 是否编译该库。\npoll库 poll库，作为Linux平台上的基本事件驱动模型，是在Linux2.1.23中引入的。Windows平台不支持poll库。\npoll与select 的基本工作方式是相同的，都是先创建一个关注事件的描述符集合，再去等待这些事件发生，然后再轮询描述符集合，检查有没有事件发生，如果有，就进行处理。\npoll库与select库主要区别在于，select库需要为读事件、写事件和异常事件分别创建一个描述符集合，因此在最后轮询的时候，需要分别轮询这三个集合。而poll库只需要创建一个集合，在每个描述符对应的结构上分别设置读事件、写事件或者异常事件，最后轮询的时候，可以同时检查这三种事件是否发生。可以说，poll是select库的优化实现。\nepoll 库 epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同。epoll 属于poll库的一个变种，实在Linux2.5.44中引入的，在Linux2.6及以上的版本都可以使用它。poll库和select库在实际工作中，最大的区别在于效率。\npoll库和select库，它们的处理方式都是创建一个待处理事件列表，然后把这个列表发给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。这样在描述符比较多的应用中，效率就显得比较低下了。一种比较好的做法是，把描述符列表的管理交由内核负责，一旦有某种事件发生，内核把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表。epoll库就是这样一种模型。\n首先，epoll库通过相关调用通知内核创建一个有N个描述符的事件列表；然后给这些描述符设置所关注的事件，并把它添加到内核的事件列表中去，在具体的编码过程中也可以通过相关调用对事件列表中的描述符进行修改和删除。\n完成设置之后，epoll库就开始等待内核通知事件发生了。某一事件发生后，内核将发生事件的描述符列表上报给epoll库。得到事件列表的epoll库，就可以进行事件处理了。\nepoll库在Linux平台上是高效的。他支持一个进程打开大数目的事件描述符，上限是系统可以打开文件的最大数目；同时epoll库的IO效率不随描述符数目增加而线性下降，因为它只会对内核上报的\u0026quot;活跃\u0026quot;的描述符进行操作。\nrtsig 模型 rtsig 是 Real-Time Singnal 的缩写，是实时信号的意思。从严格意义上说，rtsig 模型并不是常用的事件驱动模型，但Nginx服务器提供了使用实时信号对事件进行响应的支持，官方文中将rtsig模型与其他的事件驱动模型并列，rtsig 模型在Linux 2.2.19及以上的版本中可以使用。\n使用rtsig模型时，工作进程会通过系统内核建立一个rtsig 队列用于存放标记事件发生(在Nginx服务器应用中特指客户端请求发生)的信号。每个事件发生时，系统内核就会产生一个信号存放到rtsig 队列中等待工作进程的处理。\n需要指出的是，rtsig 队列有长度限制，超过该长度后就会发生溢出。默认情况下，Linux系统事件信号队列的最大长度设置为1024，也就是同时最多可存放1024个发生事件的信号。在Linux2.6.6-mm2 之前的版本中，系统各个进程的事件信号队列是由内核统一管理的，用户可以通过修改内核参数/proc/sys/kernel/rtsig-max 来自定义该长度设置。在Linux2.6.6-mm2 之后的版本中，该内核参数被取消，系统各个进程分别拥有各自的事件信号队列，这个队列的大小由Linux系统的RLIMIT_SIGPENDING 参数定义，在执行setrlimit()系统调用时确定该大小。Nginx 提供了worker_rlimit_sigpending 参数用于调节这种情况下的事件信号队列长度。\n当rtsig 队列发生溢出时，Nginx将暂时停止使用rtsig模型，而调用poll库处理未处理的事件，直到rtsig 信号队列全部清空，然后再次启动rtsig模型，以防止新的溢出发生。\nNginx 在配置文件中提供了相关的参数对rtsig 模型的使用进行配置。编译Nginx服务器时，使用--with-rtsig_modeule 配置选项来启用rtsig 模型的编译。\n其他事件驱动模型 除了以上4种主要的事件驱动模型，Nginx服务器针对特定的Linux平台提供了响应的事件驱动模型支持。目前实现的主要有kqueue 模型、/dev/poll 模型和 eventport 模型等。\nkqueue 模型 是用于支持BSD系列平台的高效事件驱动模型，主要用在FreeBSD 4.1 及以上版本、openBSD2.9及以上版本、NetBSD2.0及以上版本以及Mac OS X平台上。该模型也是poll库的一个变种，和epoll库的处理方式没有本质上的区别，都是通过避免轮询操作提供效率。该模型同时支持条件触发(level-triggered，也叫水平触发，只要满足条件就触发一个事件)和边缘触发(edge-triggered，每当状态变化时，触发一个事件)。如果在这些平台下使用Nginx服务器，则建议使用该模型用于请求处理，以提供Nginx服务器的处理性能。 /dev/poll 模型 是用于支持Unix 衍生平台的高效事件驱动模型，其主要在Solaris7 11/99及以上版本、HP/UX 11.22及以上版本、IRIX 6.5.15及以上版本和 Tru64 UNIX 5.1A 及以上版本的平台中使用。该模型是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它使用了虚拟机的/dev/poll 设备，开发人员可以将要监视的文件描述符加入这个设备，然后通过ioctl()调用来获取事件通知。在以上提到的平台中，建议使用该模型处理请求。 eventport 模型 是用于支持Solaris 10及以上版本平台的高效事件驱动模型。该模型也是Sun公司在开发Solaris系列平台时提出的用于完成事件驱动机制的方案，它可以有效防止内核奔溃等情况的发生，Nginx服务器为此提供了支持。 设计架构概览 Nginx 服务器灵活强大的功能扩展特性时其巨大的优势。前面介绍了Nginx服务器的模块，这些模块在功能上彼此独立，在逻辑上又能相互影响、相互联系、共同协作，从而构成一套功能强大完整的服务器程序。那么，Nginx服务器是如何达到这样的效果呢？这依赖于Nginx服务器的设计架构。\nNginx 服务器架构 Nginx 服务器启动后，产生一个主进程(master process)，主进程执行一系列工作后产生一个或者多个工作进程(worker processes)。主进程主要进行Nginx配置文件解析、数据结构初始化、模块配置和注册、信号处理、网络监听生成、工作进程生成和管理等工作；工作进程主要进行进程初始化、模块调用和请求处理等工作，是Nginx 服务器提供服务的主体。\n在客户端请求动态站点的过程中，Nginx 服务器还涉及和后端服务器的通信。Nginx服务器将接收到的Web请求通过代理转发到后端服务器，由后端服务器进行数据处理和页面组织，然后将结果返回。\nNginx 服务器为了提高对请求的响应效率，进一步降低网络压力，采用了缓存机制，将历史应答数据缓存到本地。在每次Nginx 服务器启动后的一段时间内，会启动专门的进程对本地缓存的内容重建索引，保证对缓存文件的快速应答。\n我们可以将Nginx 服务器的结构大致分为主进程、工作进程、后端服务器和缓存等部分。下图展示了各个部分之间的联系和交互。\nNginx架构示意图 Nginx 服务器的进程 Nginx 服务器的三大类进程： 主进程 由主进程生成的工作进程 为缓存文件建立索引的进程 主进程 Nginx 服务器启动时运行的主要进程。它的主要功能时与外界通信和对内部其他进程进行管理，具体来说有以下几点： 读取Nginx 配置文件并验证其有效性和正确性。 建立、绑定和关闭Socket。 按照配置生成、管理和结束工作进程。 接收外界指令，比如重启、升级及退出服务器等指令。 不中断服务，实现平滑重启，应用新配置。 不中断服务，实现平滑升级，升级失败进行会滚处理。 开启日志文件，获取文件描述符。 编译和处理Perl脚本。 工作进程 由主进程生成，生成数量可以通过Nginx配置文件指定，正常请情况下生存于主进程的整个生命周期。该进程的主要工作由以下几项：\n接收客户端请求。 将请求依次送入格个功能模块进行过滤处理。 IO调用，获取响应数据。 与后端服务器通信，接收后端服务器处理结果。 数据缓存，访问缓存索引、查询和调用缓存数据。 发送请求结果，响应客户端请求。 接收主程序指令，比如重启、升级和退出等指令。 工作进程完成的工作还有很多，这里列出了主要的几项。该进程是Nginx 服务器提供Web 服务、处理客户端请求的主要进程，完成了Nginx 服务器的主体工作。因此，我们应该重点监视工作进程的运行状态，保证Nginx 服务器对外提供稳定的Web服务。\n缓存索引重建及管理进程(Cache Loader \u0026amp; Cache Manager) Nginx 架构示意图中的Cache模块，主要由缓存索引重建(Cache Loader) 和缓存索引管理(Cache Manager)两类进程完成工作。缓存索引重建进程是在Nginx 服务启动一段时间之后(默认一分钟)由主进程生成，在缓存元数据重建完成后就自动退出；缓存索引管理进程一般存在于主进程的整个声明周期，负责对缓存索引进行管理。 缓存索引重建进程完成的主要工作是，根据本地磁盘上的缓存文件在内存中建立索引元数据库。该进程启动后，对本地磁盘上存放缓存文件的目录结构进行扫描，检查内存中已有的缓存元数据是否正确，并更新索引元数据库。 缓存索引管理进程主要负责在索引元数据更新完成后，对元数据是否过期做出判断。 这两个进程维护的内存索引元数据库，为工作进程对缓存数据的快速查询提供了便利。 进程交互 Nginx 服务器在使用Master-Worker模型时，会涉及主进程与工作进程(Master-Worker)之间的交互和工作进程(Worker-Worker)之间的交互。这两类交互都依赖于管道(channel)机制，交互的准备工作都是在工作进程生成时完成的。 Master-Worker 交互 工作进程是由主进程生成的(使用了fork函数)。Nginx服务器启动以后，主进程根据配置文件决定生成的工作进程的数量，然后建立一张全局的工作进程表用于存放当前未退出的所有工作进程。 在主进程生成工作进程后，将新生成的工作进程加入到工作进程表中，并建立一个单向管道并将其传递给该工作进程。该管道与普通的管道不同，它是由主进程指向工作进程的单向管道，包含了主进程向工作进程发出的指令、工作进程ID、工作进程在工作进程表中的索引和必要的文件描述符等信息。 主进程与外界通过信号机制进行通信，当接收到需要处理的信号时，它通过管道向相关的工作进程发送正确的指令。每个工作进程都有能力捕获管道中可读事件，当管道中有可读事件时，工作进程从管道读取并解析指令，然后采取相应的措施。这样就完成了Master-Worker的交互。 Worker-Worker 交互 Worker-Worker 交互在实现原理上和Master-Worker交互基本是一样的。只要工作进程之间能够得到彼此的信息，建立管道，即可通信。由于工作进程之间是相互隔离的，因此一个进程想要知道另一个进程的信息，只能通过主进程来设置了。 为了达到工作进程之间交互的目的，主进程在生成工作进程后，在工作进程表中进行遍历，将该新进程的ID以及针对该进程建立的管道句柄传递给工作进程表中的其他进程，为工作进程之间的交互做准备。每个工作进程捕获管道中可读事件，根据指令采取响应的措施。 当工作进程W1需要向W2发送指令时，首先在主进程给它的其他工作进程信息中找到W2的进程ID，然后将正确的指令写入指向W2的通道。工作进程W2捕获到管道中的事件后，解析指令并采取相应措施。这样就完成了Worker-Worker交互。 Run Loops 事件处理循环模型 Run Loops，指的是进程内部用来不停地调配工作，对事件进行循环处理的一种模型。它属于进程或者线程的基础架构部分。该模型对事件的处理不是自动的，需要在设计代码过程中，在适当的时候启动Run-Loop机制对输入的事件做出响应。\n该模型是一个集合，集合中的每一个元素称为一个Run-Loop。每个Run-Loop可运行在不同的模式下，其中可以包含它所监听的输入事件源、定时器以及在事件发生时需要通知的Run-Loop监听器(Run-Loop Obsevers)。为了监听特定的事件，可以在Run Loops中添加相应的Run-Loop监听器。当被监听的事件发生时，Run-Loop会产生一个消息，被Run-Loop 监听器捕获，从而执行预定的动作。\nNginx 服务器在工作进程中实现了Run-Loop 事件处理循环模型的使用，用来处理客户端发来的请求事件。该部分的实现可以说是Nginx 服务器程序实现中最为复杂的部分，包含了对输入事件繁杂的响应和处理过程，并且这些处理过程都是基于异步任务处理的。\n总结 Nginx 服务器的整体架构中，可以看到，Nginx 服务器提供了异步的、非阻塞的Web服务，系统中的模块各司其职，彼此之间通常使用网络、管道和信号等机制进行通信，从而保持了松耦合的关系。工作进程中事件处理机制的使用，在很大程度上降低了在网络负载繁重的情况下Nginx 服务器对内存、磁盘的压力，同时保证了对客户端请求的及时响应。\n在实际使用Nginx 服务器过程中，当磁盘没有足够的性能处理大量IO调用时，工作进程仍然可能因为磁盘读写调用而阻塞，进而导致客户端请求超时失败等问题。\n可以通过多种方法来降低对磁盘IO的调用，比如引入异步输入/输出(Input/Output,AIO)机制等，但这些方法没有从根本上解决问题。为避免产生这种问题，应当对运行环境有一个基本的了解，针对不同的网络负载环境选择相匹配的硬件环境，并对Nginx服务器进行合理的配置。\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/arch/","section":"知识存档","summary":"Nginx 服务器架构介绍","title":"Nginx architecture","type":"docs"},{"content":" Nginx配置基础指令 user 用于配置运行Nginx服务器的用户(组)的指令 只有被设置的用户或者用户组成员才有权限启动Nginx进程，如果是其他用户(test_user)尝试启用Nginx进程会报错。 如果希望所有用户都可以启动Nginx进程有两种方法： 第一种： 将这个指令注释掉。 第二种：将用户和用户组设置为默认的用户和用户组(nobody) 语法格式： user: 指定运行Nginx服务器的用户。 group: 可选项，指定可以运行nginx服务器的用户组。 作用域：全局 user [user] [group]; worker_processes worker_processes 是Nginx服务器实现并发处理服务的关键所在。 从理论上来说，worker_process的值越大，可以支持的并发处理量也越多，但实际上它还要受到来自软件本身、操作系统本身资源和能力、硬件设备(如CPU和磁盘驱动器)等的制约。 语法格式： number: 指定Nginx进程最多可以产生的worker process数。 auto: 设置该值，Nginx进程将自动检测。 作用域：全局 worker_processes number | auto; pid Nginx进程作为系统的守护进程运行，我们需要在某文件中保存当前运行程序的主进程号。 Nginx支持对它的存放路径和名称自定义配置。 语法格式： file：指定Nginx进程PID文件的存放路径和文件名称 作用域：全局 pid file; error_log 配置Nginx错误日志的存放路径和日志级别。 debug日志级别需要在编译时使用(\u0026ndash;with-debug)来开启debug日志。 设置某一级别后，比这一级别高的日志也会被记录。比如设置warn级别后，级别为warn 以及error、crit、alert和emerg的日志都会被记录下来。 语法格式： file: 指定Nginx错误日志的存放路径和文件名称。指定的文件须对运行Nginx进程的用户具有写权限，否则会报错。 stderr: 指定错误日志级别，[debug | info | notice | warn | error | crit | alert | emerg] 作用域：全局、http、server、location error_log file stderr; include 在一些情况下，我们可能需要将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中。 Nginx提供了include指令来完成配置文件的引入。 引入进来的配置文件要求须对运行Nginx进程的用户具有写权限，并且符合Nginx配置文件规定的相关语法和结构。 语法格式： file：指定要引入的配置文件，支持相对路径。 作用域: 配置文件的任意地方 include file; accept_mutex 在《UNIX 网络编程》第1卷里提到过一个叫\u0026quot;惊群\u0026quot;的问题(Thundering herd problem)，大致意思是，当某一个时刻只有一个网络连接到来时，多个睡眠进程会被同时叫醒，但只有一个进程可获得连接。如果每次唤醒的进程数目太多，会影响一部分系统性能。在Nginx服务器的多进程下，就有可能出现这样的问题。 为了解决这样的问题，Nginx配置中包含了这样一条指令accept_mutex，当其设置为开启的时候，将会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢。 语法结构： on: 开启 off: 关闭 作用域：events accept_mutex on | off; multi_accept 每个Nginx服务器的worker process都有能力同时接收多个新到达的网络连接，但是这需要在配置文件中进行配置。 语法结构： on: 开启。高负载建议开启。 off: 关闭。默认off，即每个worker process 一次只能接收一个新到达的网络连接。低负载建议关闭。 作用域：events multi_accept on | off; use Nginx服务器提供了多种事件驱动模型来处理网络消息。配置文件中为我们提供了相关指令来强制Nginx服务器选择哪种事件驱动模型进行消息处理。 在编译的是否可使用--with-select-module是否强制编译select模块到Nginx内核中，或--with-poll_module是否强制将poll模块编译到Nginx内核中。 语法结构： method：事件驱动模型。可选项：[select | poll | kqueue | epoll | rtsig | /dev/poll | eventport]。 作用域：events use method; worker_connections 主要用来设置允许每一个worker process同时开启的最大连接数。 语法格式： number：指定最大连接数，默认512。不仅仅包括用户建立的连接数，而是包括所有可能的连接数，且该值不能大于操作系统支持打开的最大文件句柄数量65535。Linux 可以使用ulimit -n查看句柄数。 作用域：events worker_connections number; default_type 在常用的浏览器中，可以显示的内容有HTMl、XML、GIF及Flash等种类繁多的文本，媒体等资源，浏览器为区分这些资源，需要使用MIME Type。 MIME Type是网络资源的媒体资源。Nginx作为Web服务器，必须能够识别前端请求的资源类型。 在默认的Nginx配置文件中，在http块中有include mime.types;配置，从mim.type文件内容片段可以看到，定义了一个types结构，结构中包含了浏览器能够识别的MINE类型以及对应于相关类型的文件后缀名。由于mime.types文件是主配置文件应用的第三方文件，因此，types也是Nginx配置文件中的一个配置块，称之为types块，其用于定义MIME类型。 default_types指令用于处理前端请求的MIME类型。 语法结构： mime-type：是types块中定义的MIME-Type。默认值为text/plain。 作用域：http、server、location default_type mime-type; access_log 用于记录Nginx服务器提供服务过程中应答前端请求的日志，称之为服务日志。 Nginx服务器支持对服务日志的格式、大小、输出等进行配置。 语法格式： path：配置服务日志的文件存放路径和名称。 format：可选项，自定义服务日志的格式字符串，也可以通过“格式字符串”名称使用log_format指令定义好的格式。 buffer=size：配置临时存放服务日志的内存缓存区大小。 off：取消记录服务日志 作用域：http、server、location access_log path [format[buffer=size]] | off; log_format 用于定义服务日志的格式，并且可以为格式字符串定义一个名称，以便access_log指令可以直接调用。 语法格式： name：格式字符串的名称，默认名称combined string：服务日志的格式字符串。在定义的过程中，可以使用Nginx配置预设的一些变量获取相关内容，变量名称使用双引号括起来，string整体使用单引号括起来。在string中可以使用的变量参见 Nginx 内置变量\r作用域：http log_format name string \u0026hellip;; 来看一个示例：\nlog_format exampleLog \u0026#39;$remote_addr - [$time_local] $request \u0026#39; \u0026#39;$status $body_bytes_sent $http_referer \u0026#39; \u0026#39;$http_user_agent\u0026#39;; 这条配置定义了服务日志文件的名称为 exampleLog。来看测试结果\n192.168.1.1 - [15/Oct/2024:19:20:41 +0800] \u0026#34;GET / HTTP/1.1\u0026#34; 200 151 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)\u0026#34; 192.168.1.1 - [15/Oct/2024:19:20:41 +0800] \u0026#34;GET /favicon.ico HTTP/1.1\u0026#34; 404 570 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)\u0026#34; 简单分析一下第二条日志，$remote_addr获取到用户机的IP地址为192.168.1.1，$time_local获取到本地时间为15/Oct/2024:19:20:41 +0800，$request获取到请求为GET /favicon.ico HTTP/1.1，$status获取到请求状态为404，$body_bytes_sent 获取到请求体的大小为570B，$http_referer未获取到任何内容，$http_user_agent获取到用户使用Mozilla浏览器。\n通过分析可以看到，在正常情况下，对于绝大多数的内置变量，Nginx服务器都能够获取到相关内容，但也会出现空值的情况。\nsendfile 在Apache、lighttpd 等Web服务器配置中，都有和sendfile相关的配置。 sendfile 是一种高效的文件传输机制，它允许服务器直接在内核空间和文件系统之间传输文件，而无需将文件内容复制到用户空间。这样可以显著提高文件传输的效率和性能，特别是对于大文件或高负载的情况。 sendfile 指令只适用于传输静态文件，对于动态内容（如 PHP 脚本输出）不适用。 语法格式： on：开启 off：关闭 作用域：http、server、location sendfile on | off; sendfile_max_chunk 用于设置每个 sendfile 传输的最大字节数。 当需要传输的文件大小超过size此值时，Nginx 会分割文件并使用多个 sendfile 操作进行传输。 其中，size值如果大于0，Nginx进程的每个worker process每次调用sendfile()传输的数据量最大不能超过这个值；如果设置为0，则无限制。 语法结构： size：传输的字节数大小，默认为0 作用域：http、server、location sendfile_max_chunk size; keepalive_timeout 与用户建立会话连接后，Nginx服务器可以保持这些连接打开一段时间。 语法结构： timeout：服务器端对连接的保持时间，以秒为单位。默认值为75s header_timeout：可选项，用于设置在发送响应头后等待客户端发送请求头的超时时间。如果在该时间内没有收到新的请求头，服务器将关闭连接。在应答报文头部的Keep-Alive域设置超时时间：Keep-Alive: timout=header_timeout。报文中的这个指令可以被Mozilla或者Konqueror识别。 作用域：http、server、location keepalive_timeout timeout [header_timout]; keepalive_requests Nginx服务端和用户端建立会话连接后，用户端通过此连接发送请求。 keepalive_requests指令用于限制用户通过某一连接向Nginx服务器发送请求的次数。 语法格式： number：设置用户端发送请求的次数。默认为100 作用域：http、server、location keepalive_requests number; listen 用于网络监听，配置方法主要有三种：\n监听IP地址 监听端口 监听域名 监听IP的语法结构： listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]; 监听端口的语法结构： listen address port [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl]; 监听UNIX Domain Socket(一种在原有Socket框架上发展起来的IPC机制，用于在单个主机上执行客户/服务器通信。)的语法结构： listen unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ssl]; address：IP地址，如果是IPv6的地址，需要使用中括号\u0026quot;[]\u0026ldquo;括起来。 port：端口号，如果只定义了IP地址没有定义端口号，就使用80端口。 path：socket文件路径，如/var/run/nginx.sock等 default_server：标识符，将此虚拟主机设置为address:port的默认主机。 setfib=number：Nginx-0.8.44中使用这个变量监听socket关联路由表，目前只对FreeBSD起作用，不常用。 backlog=number：设置监听函数listen()最多允许多少网络连接同时处理挂起状态，在FreeBSD中默认为-1，其他平台默认511。 rcvbuf=size：设置监听socket接收缓存区大小。 sndbuf=size：设置监听socket发送缓存区大小。 deferred：标识符，将accept()设置为Deferred模式。 accept_filter=filter：设置监听端口对请求的过滤，被过滤的内容不能被接收和处理。该指令只在FreeBSD和NetBSD 5.0+平台下有效。filter可以设置为dataready或httpready bind：标识符，使用独立的bind()处理此address:port；一般情况下，对于端口相同而IP地址不同的多个连接，Nginx服务器将只使用一个监听命令，并使用bind()处理端口相同的所有连接。 ssl：标识符，设置会话连接使用SSL模式进行，此标识符和Nginx服务器提供的HTTPS服务有关。 作用域：server 下面给出一些示例开说明listen的用法\nlisten *:80 | *:8080； # 监听所有80端口和8080端口。 listen 192.168.1.1：8000； # 监听具体的IP和具体的端口上的连接 listen 192.168.1.1; # 监听具体的IP的所有端口上的连接 listen 8000; # 监听具体端口上的所有IP连接，等同于 listen *:8000; listen 192.168.1.1 default_server backlog=1024; # 设置192.168.1.1的连接请求默认此虚拟主机处理，并且允许最多1024网络连接同时处于挂起状态。 server_name 是指server块对外提供的虚拟主机。设置了主机的名称并配置好DNS，用户就可以使用这个名称向此虚拟主机发送请求了。 语法结构： name：域名。对于name来说，可以只有一个域名，也可以由多个域名并列，之间用空格隔开。也可以使用IP地址，但是这种方式不推荐。 server_name name \u0026hellip;; 下面给出一些示例来说明server_name的用法\nserver_name myserver.com www.myserver.com; 在该例中，Nginx服务器规定，第一个名称作为此虚拟主机的主要名称。\nserver_name *.myserver.com www.myserver.*; 在该例中，name可以使用通配符*，但通配符只能用在由三段字符串组成的名称的首段和尾段，或者由两段字符串组成的名称的尾段。\nserver_name ~^www\\d+\\.myserver\\.com$; name还可以使用正则表达式，并使用波浪号~作为正则表达式字符串的开始标记。在该例中，正则表达式的含义：以www开头(使用^标记)，紧跟一个或多个0~9的数字(\\d+的含义，其中，\\d代表0~9的某一个数字，+代表之前的一个字符出现一次或者多次)，再紧跟.myserver.co(由于.在正则表达式中有特殊含义，因此需要使用\\进行转义)，最后以m结束(由$标记)。关于正则表达式的相关内容参见 正则表达式\rserver_name ~^www\\.(.+)\\.com$; Nginx从0.7.40版本开始，name中的正则表达式支持字符串捕获功能。当请求通过www.myserver.com到达Nginx服务器端时，将会被上面的正则表达式配置成功，其中的myserver将会被捕获，并记录到$1中。在本server块的下文配置中，当需要myserver时，就可以使用$1代替myserver了。\n由于server_name指令支持使用通配符和正则表达式两种配置名称的方式，因此在包含有多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的server_name匹配成功。那么，来自这个名称的请求到底要交给哪个虚拟主机处理呢？Nginx服务器做出如下规定： a. 对于匹配方式不同的，按照以下的优先级选择虚拟主机，排在前面的优先处理请求。\n① 准确匹配server_name ② 通配符在开始时匹配server_name成功 ③ 通配符在结尾时匹配server_name成功 ④ 正则表达式匹配server_name成功 b. 在以上四种匹配方式中，如果server_name被处于同一优先级的匹配方式多次匹配成功，则首次匹配成功的虚拟主机处理请求。\n配置location块 语法结构: location [ = | ~ | ~* | ^~ ] uri {\u0026hellip;\u0026hellip;} uri：变量是待匹配的请求字符串，可以是不含正则表达的字符串，如/myserver.php等，称之为标准uri；可以是包含有正则表达的的字符串，如\\.php$(表示以.php结尾的URL)等，称之为正则uri。 方括号部分是可选项，用来改变字符串与uri的匹配方式。 在不添加方括号选项时，Nginx服务器首先在server块的多个location块中搜索是否有标准uri和请求字符串匹配，如果有多个可以匹配，旧纪录匹配度最高的一个。然后服务器再用location块中的正则uri和请求字符串匹配，当第一个正则uri匹配成功，结束搜索，并使用这个location块处理次请求；如果正则匹配全部失败，就是用刚才记录的匹配度最高的location块处理此请求。\n=：用于标准uri前，要求请求字符串与uri严格匹配。如果已经匹配成功，就停止继续搜索并立即处理此请求。 ~：用于表示uri包含正则表达式，并且区分大小写。 ~*：用于表示uri包含正则表达式，并且不区分大小写。 ^~：用于标准uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。 注意： 在浏览器传送URI时对一部分字符进行URI编码，比如空格被编码为%20，问号被编码为%3f等。^~有一个特点是，它对uri中的这些符号将会进行编码处理。比如，如果location块收到的URI为 html%20/data，则当Nginx服务器搜索到配置为 ^~ /html /data 的location时，可以匹配成功。\nroot Web服务器接收到网络请求之后，首先要在服务器端指定目录中寻找请求资源。在Nginx服务器中，指令root就是用来配置这个根目录的。 语法结构： path：path为Nginx服务器接收到请求以后查找资源的根目录路径。path变量中可以包含Nginx服务器预设的大多数变量，只有 $document_root 和 $realpath_root 不可以使用。 作用域：http、server、location root path; root指令的一个示例为：\nlocation /data/ { root /locationtest1; } 当location块接收到了/data/index.htm的请求时，将在/locationtest1/data/目录下找到index.htm响应请求。\nalias 在location块中，除了使用root指令指明请求处理根目录，还可以使用alias指令改变location接收到的URI的请求路径。 语法结构： path：path即为修改后的根路径。同样，此变量中也可以包含除了$document_root 和 $realpath_root之外的其他Nginx服务器预设变量。 alias path; 示例：\nlocation ~ ^/data/(.+\\.htm|htm)$ { alias /locationtest1/other/$1; } 当此location块接收到 /data/index.htm 请求时，匹配成功，之后根据alias指令的配置，Nginx服务器将到/locationtest1/other目录下找index.htm并响应请求。可以看到，通过alias指令的配置。根路径已经从/data 更改为/locationtest1/other 了。\nindex 用于设置网站的默认首页，它一般可以有两个作用： 1：用户在发出请求访问网络时，请求地址可以不写首页名称 2：可以对一个请求，根据其请求内容而设置不同的首页。 语法结构： file：file变量可以包括多个文件名，期间使用空格分隔，也可以包含其他变量。此变量默认为index.html。 index file \u0026hellip;; 示例：\nlocation ~ ^/data/(.+)/web/ $ { index index.$1.html index.my1.html index.html; } 当location块接收到 /data/locationtest/web/时，匹配成功，它首先将预置变量$1 置为locationtest，然后在/data/locationtest/web/路径下按照index的配置次序依次寻找index.locationtest.html页、index.my1.html页 和 index.html页，首先找到哪个页面，就是用哪个页面响应请求。\nerror_pgae Nginx服务器设置网络错误页面的指令为error_page。 语法结构： code：要处理的HTTP错误代码，参见 HTTP 常见错误代码\rreponse：可选项，将code指定的错误代码转化为新的错误代码response。 uri：错误页面的路径或者网站地址。如果设置为路径，则是以Nginx服务器按照路径下的html目录作为根路径的相对路径；如果设置为网址，则Nginx服务器会直接访问该网址获取错误页面，并返回给用户端。 作用域：http、server、location error_page code [=[response]] uri; 示例：\nerror_page 404 /404.html; 设置Nginx服务器使用Nginx安装路径/html/404.html 页面响应404错误。\nerror_page 403 http://somewebsite.com/forbiden.html; 设置Nginx服务器使用http://somewebsite.com/forbiden.html页面响应403错误。\nerror_page 410 =301 /empty.gif; 设置Nginx服务器产生410的HTTP消息时，使用Nginx安装路径/html/empty.gif 返回给用户端301消息。\n从error_page指令分析中可以看到，，变量uri实际上是一个相对于Nginx服务器安装路径的相对路径。那么，如果不想将错误页面放到Nginx服务器的安装路径下管理，该怎么做？很简单，只需要将另外使用一个location指令定向错误页面到新的路径下面就可以了。\n对于上面第一个示例，我们希望Nginx服务器使用/myserver/errorpages/404.html页面响应404错误。\nerror_page 404 /404.html; location /404.html { root /myserver/errorpages/; } 首先捕获404.html请求，然后将请求定向到新的路径下面即可。\nallow Nginx配置通过两种途径支持基本访问权限的控制，其中一种是由HTTP标准模块ngx_http_access_module支持的，其通过IP来判断客户端是否拥有对Nginx的访问权限。 用于设置允许访问Nginx的客户端IP。 语法结构： address：允许访问的客户端IP，不支持同时设置多个。如果有多个IP需要设置，需要重复使用allow指令。 CIDR：允许访问的客户端的CIDR地址，例如 202.80.18.23/25，前面是32位IP地址，后面/25代表该IP地址中前25位是网络部分，其余位代表主机部分。 all：代表允许所有客户端访问。Nginx 0.8.22版本后也支持ipv6地址。 作用域：http、server、location allow address | CIDR | all; 示例：\nallow 2620:108:e000::8001; deny 作用刚好和allow相反，它用于设置禁止访问Nginx的客户端IP。 语法结构： address：禁止访问的客户端IP，不支持同时设置多个。如果有多个IP需要设置，需要重复使用deny指令。 CIDR：禁止访问的客户端的CIDR地址。 all：代表禁止所有客户端访问。 作用域：http、server、location deny address | CIDR | all; 示例：\nlocation { deny 192.168.1.1; allow 192.168.1.0/24; deny all; } 这个示例中，首先配置禁止192.168.1.1访问Nginx，然后配置允许192.168.1.0/24访问Nginx，最后又使用all配置禁止所有IP的访问，那么，192.168.1.0/24客户端到底可不可以访问呢？是可以的。\nNginx配置在解析的过程中，遇到deny指令或者allow指令是按照顺序对当前客户端的连接进行访问权限检查的。如果遇到匹配的配置时，则停止继续向下搜索相关配置。因此，当192.168.1.0/24客户端访问时，Nginx在第3行解析配置发现允许该客户端访问，就不会继续向下解析第4行了。\nauth_basic Nginx还支持基于HTTP Basic Authentication协议的认证。该协议时一种HTTP性质的认证办法，需要识别用户名和密码，认证失败的客户端不拥有访问Nginx服务器的权限。该功能由HTTP标准模块ngx_http_auth_basic_module支持。 语法结构： string：开启该认证功能，并配置验证时的指示信息。 off：关闭该认证功能。 auth_basic string | off; auth_basic_user_file 用于设置包含用户名和密码信息的文件路径。 语法结构： file：密码文件的绝对路径。支持明文或者密码加密后的文件。 auth_basic_user_file file; 加密密码可以使用crypt()函数进行密码加密的格式，可以使用htpasswd命令生成。\nhtpasswd -c -d /nginx/conf/pass_file username # 运行后输入密码即可 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/instruct/","section":"知识存档","summary":"Nginx 基础指令介绍","title":"Nginx Instruct","type":"docs"},{"content":" Nginx 主配置文件介绍 nginx.conf 文件结构 { ...... # 全局块 events { # events块 ...... } http { # http块 ...... # http全局块 server { # server块 ...... # server全局块 location { # location块 ...... } } ...... # http全局块 } } 最外层的花括号将内容整体分为两个部分，再加上最开始的内容，即第一行省略号表示的。nginx.conf一共由三部分组成，分别为全局块、events块和http块。在http块中，又包含http全局块、多个server块。每个server块中，可以包含server全局块和多个location块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。\n配置文件支持大量可以配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同。一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用\u0026quot;就近原则\u0026quot;，即以较低层级块中的配置为准。\n全局块 全局块是默认配置文件从开始到events块之间的一部分内容，主要设置一些影响Nginx服务器整体运行的配置指令，因此，这些指令的作用域是Nginx服务器的全局。\n通常包括配置运行Nginx服务器的用户(组)、允许生成的worker process数、Nginx进程PID存放路径、日志的存放路径和类型以及配置文件的引入等。\nevents块 events块涉及的指令主要影响Nginx服务器与用户的网络连接。常用到的设置包括是否开启对多worker process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取那种事件驱动模型处理连接请求，每个worker process可以同时支持的最大连接等。\n这一部分的指令对Nginx服务器的性能影响较大，在实际配置中应该根据实际情况灵活调整。\nhttp块 http块是nginx服务器配置中的重要部分，代理、缓存、和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。\n可以在http全局块中配置的指令包括文件引入、MIME-Type定义、日志自定义、是否是否sendfile传输文件、连接超时时间、单连接请求数上限等。\nserver块 server块和\u0026quot;虚拟主机\u0026quot;的概念有密切联系。为了加深对相关配置的理解，在介绍server块之前，简单了解一下虚拟主机的相关内容。\n虚拟主机，又称虚拟服务器、空间主机或是网页空间，它是一种技术。该技术是为了节省互联网服务器硬件成本而出现的。这里的\u0026quot;主机\u0026quot; 或 \u0026ldquo;空间\u0026rdquo; 是由实体的服务器延伸而来，硬件系统可以基于服务器群，或者单个服务器等。虚拟主机技术主要应用于HTTP、FTP及EMAIL等多项服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。从用户角度来看，一台虚拟主机和一台独立的硬件主机是完全一样的。\n在使用Nginx服务器提供Web服务时，利用虚拟主机的技术就可以避免为每一个要运行的网站提供单独的Nginx服务器，也无需为每个网站对应运行一组Nginx进程。虚拟主机技术使得Nginx服务器可以在同一台服务器上只运行一组Nginx进程，就可以运行多个网站。本节介绍的server块就是用来完成这个功能的。\n每个server块就相当于一台虚拟主机，它内部可有多台主机联合提供服务，一起对外提供在逻辑上密切的一组服务(或网站)。server全局块的指令的作用域为本server块，不会影响其他的server块。\nserver块也可以包含自己的全局块，同时可以包含多个location块。在server全局块中，最常见的的两个配置项是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。\n注意: http全局块部分指令可以在server块中和location块中使用。\nlocation块 每个server块中可以包含多个location块。location其实是server块的一个指令，知识由于其在整个Nginx配置文档中起着重要的作用，而且Nginx服务器在许多功能上的灵活性往往在location指令的配置中体现出来。\n这些location块的主要作用是，基于Nginx服务器接收到的请求字符串(例如：server_name/url-string)，对除虚拟主机名称(也可以是IP别名)之外的字符串(前例中 \u0026ldquo;/uri-string\u0026quot;部分)进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能都是在这部分实现。需多第三方模块的配置也是在location块中提供功能。\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/config/","section":"知识存档","summary":"Nginx 配置文件结构介绍","title":"Nginx Config","type":"docs"},{"content":" 与事件驱动模型相关配置的8个指令 use 指令 该指令用于指定Nginx 服务器使用的事件驱动模型。 worker_connections 指令 该指令用于设置Nginx服务器的每个工作进程允许同时连接客户端的最大数量。结合worker_processes 指令，可以计算出nginx 服务器允许同时连接的客户端最大数量Client= worker_processes * worker_connetions/2。 在使用Nginx服务器的过程中，可能会遇到无法访问Nginx 服务器的情况，查看日志发现报以下错误。 [alert] 24082#0: 1024 worker_connections is not enough while accepting new connection 0.0.0.0:81 根据报错信息，推测可能是Nginx服务器的最大访问连接数设置小了。该指令设置的就是Nginx服务器能接受的最大访问俩，其中包括前端用户连接也包括其他连接，这个值在理论上等于该指令的值与它允许开启的工作进程最大数的乘积。一般设置为65535。\nworker_connencionts 65535; 该指令的赋值与Linux操作系统进行可以打开的文件句柄数量有关系。按照以上设置以后，Nginx报以下错误。\n[warn]: 8192 worker_connections are more than open file resource limit: 1024 究其原因，Linux系统中有一个系统指令 open file resource limit，它设置了进程可以打开的文件句柄数量。worker_connections指令的赋值当然不能超过open file resource limit 的赋值。可以使用以下命令查看linux系统中open file resource limit 指令的值。\n# cat /proc/sys/fs/file-max 可以通过以下命令将 open file resource limit指令的值设为2390251 # echo \u0026#34;2390252\u0026#34; \u0026gt; /proc/sys/fs/file-max; sysctl -p 这样，Nginx 的worker_connections 指令赋值65535 就没问题了。\nworker_rlimit_sigpending 指令 该指令用于设置Linux2.6.6-mm2版本后的Linux平台的事件信号队列长度上限。 该指令主要影响事件驱动模型中rtsig模型可以保存的最大信号数。Nginx服务器的每一个工作进程有自己的事件信号队列用于暂存客户端请求发生信号，如果超出长度限制，Nginx服务器自动转用poll模型处理未处理的客户端请求。为了保证Nginx 服务器对客户端请求的高效处理，请根据实际的客户端请求数量和服务器运行环境的处理能力设定该值。 wowrker_rlimit_sigpending 1024; devpoll_changes 和 devpoll_events 指令 这两个指令用于设置在/dev/poll事件驱动模式下Nginx服务器可以与内核之间传递事件的数量。前者设置传递给内核的事件数量，后者设置从内核获取的事件数量。 devpoll_changes number; devpoll_events number; 其中number为要设置的数量，默认值均为512。 使用kequeue_changes 方式，可以设置与内核之间传递事件的数量。 epoll_events 指令 该指令用于设置在epoll 事件驱动模式下Nginx 服务器可以与内核之间传递事件的数量。 epoll_events number; 其中，number 为要设置的数量，默认值均为512。 注意: 与其他事件驱动模型不同，在epoll事件驱动模式下Nginx 服务器向内核传递事件的数量和从内核传递的事件数量是相等的 ，因此没有类似epoll_changes这样的指令。\nrtsig_signo 指令 该指令用于设置rtsig模式使用的两个信号中的第1个，第2个信号是在第1个信号的编号上加1， rtsig_signo signo; 默认第1个信号设置为 SIGRTMIN+10 提示： 在Linux中可以使用以下命令查看系统支持的SIGRTMIN有哪些。\nkill -l | grep SIGRTMIN rtsig_overflow_* 指令 该指令代表三个具体的指令，分别为 rtsig_overflow_events、rtsig_overflow_test和rtsig_overflow_threshold 指令。这些指令用来控制当rtsig模式中信号对列溢出时Nginx 服务器的处理方式。 rtsig_overflow_* number; # 这里的* 代表提到的三个指令。 其中，number为要设置的值。 rtsig_overflow_events 指令指定队列溢出时使用poll库处理的事件数，默认值为16. rtsig_overflow_test 指令指定poll库处理完第几件事件后将清空rtsig模型使用的信号队列，默认值为32. rtsig_overflow_threshold 指令指定 rtsig 模式使用的信号队列中的事件超过多少时就需要清空队列了。该指令只对Linux 2.4.x 及以下版本有效。在这些版本中包含两个参数：分别是/proc/sys/kernel/rtsig-nr 和 /proc/sys/kernel/rtsig-max/rtsig_overflow_threshold，后者就是该指令设定的值。当Nginx 服务器检测到前者大于后者时，将清空队列。该指令默认值为10，代表rtsig-max的1/10。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/hightconf/drive/","section":"知识存档","summary":"与事件驱动相关的指令配置","title":"Nginx Drive model optimization","type":"docs"},{"content":" 与网络连接的相关配置的4个指令 keepalive_timeout 指令 该指令用于设置Nginx服务器与客户端保持连接的超时时间。支持两个选项，用空格隔开。第一个选项指定客户端连接保持活动的超时时间，在这个时间之后，服务器会关闭此连接；第二个选项可选，指定了使用Keep-Alive消息头保持活动的有效时间，如果不设置，Nginx服务器不会向客户端发送Keep-Alive消息头以保持与客户端某些浏览器(如Mozilla、Konqueror等)的连接，超过设置的时间后，客户端就可以关闭连接，而不需要服务器关闭了。建议从服务器的访问数量、处理速度以及网络状况方面考虑此值。 keepalive_timeout 60 50; 此设置表示Nginx服务器与客户端连接保持活动的时间是60s，60s后服务器与客户端断开连接；使用keep-alive消息头保持与客户端某些浏览器的连接时间为50s，50s秒后浏览器主动与服务器断开连接。\nsend_timeout 指令 该指令用于设置Nginx服务器响应客户端的超时时间，这个超时时间仅针对两个客户端和服务器之间建立连接后，某次活动之间的时间。如果这个时间后客户端没有任何活动，Nginx 服务器将会关闭连接。需要考虑服务器访问数量和网络状况等方面。 send_timeout 10s; 该设置表示Nginx 服务器与客户端建立连接后，某次会话中服务器等待客户端响应超时10s，就会自动关闭连接。\nclient_header_buffer_size 指令 该指令用于设置Nginx 服务器允许的客户端请求头部的缓冲区大小，默认为1KB。可以根据系统分页大小来设置。 分页大小可以用以下命令获取： #getconf PAGESIZE 有时可能会遇到Nginx 服务器返回400 错误的情况，查找该错误原因比较困难，出现错误的时候，通常再浏览器和日志里也看不到任何有关的提示信息。根据实际经验来看，有很大一部分情况是客户端的请求头部过大造成的，通常是客户端cookie中写入了较大的值引起的。\nclient_header_buffer_size 4k; multi_accept 指令 该指令用于配置Nginx服务器是否尽可能多地接收客户端的网络连接请求，默认值off。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/hightconf/network/","section":"知识存档","summary":"针对网络连接的指令配置","title":"Nginx networker optimization","type":"docs"},{"content":" Nginx安装目录介绍 Nginx服务器的安装目录中主要包括了conf、html、logs、sbin等4个目录。 conf: 目录中存放了Nginx的所有配置文件。其中,nginx.conf文件是Nginx服务器的主配置文件，其他配置文件使用来配置Nginx的相关功能的。比如，配置fastcgi使用的fastcgi.conf和fastcgi_params两个文件。所有的配置文件都提供了以.default结尾的默认配置文件，方便我们将配置过的.conf文件恢复到初始状态。 html: 目录中存放了Nginx服务器在运行过程中调用的一些HTML网页文件。 logs: 是用来存放Nginx服务器的日志文件的。Nginx的日志功能比较强大，有不同的种类，并且可以自定义输出格式内容等。 sbin: 目录存放名称为nginx的二进制文件，是Nginx主程序。 Nginx服务的信号控制 Nginx服务在运行时，会保持一个主进程和一个或多个worker process工作进程。通过给Nginx服务器的主进程发送信号就可以控制服务的启停了。如何给主进程发送信号，需要知道Nginx主进程的进程号PID。\n获取PID有两个途径：一个是，在Nginx服务启动以后，默认在Nginx服务器安装目录下的logs目录中会生产文件名为nginx.pid文件，此文件中保持的就是Nginx服务主进程的PID。这个文件的存放路径和文件名都可以在Nginx服务器的配置文件中进行配置。第二个获取Nginx服务主进程PID的方法是使用Linux平台下查看进程的工具ps\nNginx服务可接收的信号 信号 作用 TERM 或 INT 快速停止Nginx服务 QUIT 平缓停止Nginx服务 HUP 使用新的配置文件启动进程，之后平缓停止原有进程，也就是所谓的 \u0026ldquo;平滑重启\u0026rdquo; USR1 重新打开日志文件，常用于日志切割。 USR2 使用新版本的Nginx文件启动服务,之后平缓停止原有的Nginx进程，也就是所谓的 \u0026ldquo;平滑升级\u0026rdquo; WINCH 平缓停止worker process，用于Nginx服务器平滑升级 向Nginx服务主进程发送信号也有两种方法。一种是使用Nginx二进制文件。另一种是使用kill命令发送信号。\nkill SIGNAL PID # SIGANL 用于指定信号，即指定表中的某一个 # PID 指定Nginx服务主进程的PID，也可以使用nginx.pid动态获取PID号。 kill SIGNAL `filepath` # filepath 为 nginx.pid的路径。 Nginx服务的启动 Nginx 使用说明 参数 说明 -?,-h 显示帮助信息。 -v 打印Nginx版本号。 -V 打印Nginx版本号和编译信息。 -t 检查Nginx服务器配置文件是否有语法错误。 -q 可以与 \u0026ldquo;-t\u0026rdquo; 联用，如果配置文件没有错误，则不输出任何信息。 -c 指定启动Nginx服务使用的配置文件。可以与 \u0026ldquo;-t\u0026rdquo; 联用，使输出内容更详细，对查找配置文件中的语法错误很有帮助 -s signal 用来向Nginx服务的主进程发送信号。stop, quit, reopen, reload -p prefix 用来改变Nginx的安装路径，常用在平滑升级Nginx服务器的场合 -g directives 用来补充Nginx配置文件，向Nginx服务指定启动时应用于全局的配置 Nginx服务的停止 停止Nginx服务有两种方法：\n快速停止：是指立即停止当前Nginx服务正在处理的所有网络请求，马上丢弃连接，停止工作。 平缓停止：是指允许Nginx服务将当前正在处理的网络请求处理完成，但不再接收新的请求，之后关闭连接，停止工作。 ./nginx -g TERM | INT | QUIT # TERM 和 INT 信号用于快速停止，QUIT用于平缓停止。 # 或者： kill TERM | INT | QUIT `/nginx/logs/nginx.pid` # 当然也可以使用kill命令向Nginx进程发送-9 或者SIGKILL信号强制关闭Nginx服务，但不建议这样使用。 kill -9 | SIGKILL `/nginx/logs/nginx.pid` Nginx服务的重启 更改Nginx服务器的配置和加入新模块后，如果希望当前的Nginx服务应用新的配置或使用新模块生效，就需要重启Nginx服务。\n平滑重启是这样一个过程，Nginx服务进程接收到信号后，首先读取新的Nginx配置文件，如果配置语法正确，则启动新的Nginx服务，然后平缓关闭旧的服务进程；如果新的Nginx配置有问题，将显示错误，仍然使用旧的Nginx进程提供服务。\n使用以下命令实现Nginx平滑重启\n./nginx -g HUP [-c newConfFile] # HUP 信号用于发送平滑重启信号 # newConfFile， 可选项，用于指定新配置文件的路径 kill HUP \u0026#39;/nginx/logs/nginx.pid\u0026#39; # 也可以实现平滑重启 Nginx服务器的升级 如果要对当前的Nginx服务器进行版本升级，应用新模块，最简单的方法就是停止当前Nginx服务，然后开启新的Nginx服务，但这样就会导致在一段时间内，用户无法访问服务器。为了解决这个问题，Nginx服务器提供平滑升级的功能。\n平滑升级的过程是这样的，Nginx服务接收到USR2信号后，首先将旧的nginx.pid文件添加后缀.oldbin，变为nginx.pid.oldbin文件；然后执行新版本Nginx服务器的二进制文件启动服务。如果新的服务启动成功，系统中将有新旧两个Nginx服务共同提供Web服务。之后，需要向旧的Nginx服务进程发送WINCH信号，使旧的Nginx服务平滑停止，并删除nginx.pid.oldbin文件。在发送WINCH信号之前，可以随时停止新的Nginx服务。\n注意：\n为了实现Nginx服务器的平滑升级，新的服务器安装路径应该和旧的保持一致。因此建议在安装新的服务器之前先备份旧的服务器。如果由于某种原因无法保持新旧服务器安装路径一致，则可以先使用以下命令将旧服务器的安装路径更改为新服务器的安装路径。\n./nginx -p newInstallPath newInstallPath 为新服务器的安装路径。之后备份旧服务器，安装新服务器即可。 做好准备工作以后，使用以下命令实现Nginx服务的平滑升级\n./nginx -g USR2 # 或者 kill USR2 `/nginx/logs/nginx.pid` USR2信号用于发送平滑升级信号。 通过ps -ef |grep nginx 查看新的Nginx服务启动正常，再使用：\n./nginx -g WINCH # 或者 kill WINCH \u0026#39;/nginx/logs/nginx.pid\u0026#39; WINCH信号用于发送平滑停止旧服务信号。这样就在不停止提供Web服务的前提下完成了Nginx服务器的平滑升级。\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/working/","section":"知识存档","summary":"Nginx 安装目录介绍","title":"Nginx Working","type":"docs"},{"content":" Nginx源码包介绍 sre: 目录中存放了Nginx软件的所有源代码。 man: 目录中存放了Nginx软件的帮助文档。 html: 目录下存放了两个后缀名为.html的静态网页文件，与nginx服务器的运行相关。 conf: 目录下存放了Nginx软件的配置文件,包含Nginx服务器的基本配置文件和对部分特性的配置文件。 auto: 目录中存放了大量脚本文件，和configure脚本程序相关。 configure: 文件是Nginx软件的自动脚本程序。运行configure自动脚本一般会完成两项工作：一是检查环境，根据环境检查结果生成C代码；二是生成编译代码所需要的Makefile文件。 configure脚本支持的常用选项 nginx_configure 选项 说明 --help 打印帮助信息 --prefix=PATH 设置nginx安装路径。默认/usr/local/nginx/ --sbin-path=PATH 设置nginx可执行文件安装路径。默认\u0026lt;prefix\u0026gt;/sbin/ --modules-path=PATH 设置nginx动态模块安装目录。默认值为\u0026lt;prefix\u0026gt;/modules/ --conf-path=PATH 设置nginx配置文件nginx.conf的安装路径。默认\u0026lt;prefix\u0026gt;/conf/ --error-log-path=PATH 设置nginx错误日志的安装路径。默认/logs/ --pid-path=PATH 设置nginx主进程pid文件nginx.pid的安装路径。默认\u0026lt;prefix\u0026gt;/logs/ --lock-path=PATH 设置nginx锁文件 nginx.lock 的安装路径。默认/var/lock/ --user=USER 设置启动nginx 进程用户。默认nobody --group=GROUP 设置启动nginx进程用户组。默认nobody --build=NAME 设置一个可选的nginx编译名称。 --builddir=DIR 设置编译时生成的目录。 --with-select_module 启用select()方法模块，select是一种信号处理模式。 --with-poll_module 启用poll()方法模块，poll是信号处理的一种方法，与select类似，轮询方法处理信号。 --with-threads 启用线程池支持。 --with-file-aio 设置nginx异步文件I/O --with-http_ssl_module 设置nginx支持https协议，运行此模块需要OpenSSL库。 --with-http_v2_module 设置nginx支持http2协议。 --with-http_realip_module 设置nginx获取客户端真实IP地址。 --with-http_addition_module 设置nginx响应前后添加文本。 --with-http_xslt_module 设置nginx支持使用一个或多个 XSLT 样式表转换 XML 响应的过滤器。运行此模块需要libxml2和libxslt库。 --with-http_xslt_module=dynamic 设置nginx支持使用一个或多个 XSLT 样式表转换 XML 响应的过滤器。运行此模块需要libxml2和libxslt库。 --with-http_image_filter_module 设置nginx支持将图像转换为JPEG、GIF、PNG和WebP格式 --with-http_image_filter_module=dynamic 设置nginx支持将图像动态的转换为JPEG、GIF、PNG和WebP格式 --with-http_geoip_module 设置nginxz支持使用预编译的MaxMind数据库，根据客户端IP地址创建变量值 ，读取ip所在地信息。 --with-http_geoip_module=dynamic 设置nginxz支持使用预编译的MaxMind数据库，根据客户端IP地址创建变量值 ，读取ip所在地信息。 --with-http_sub_module 设置nginxz支持将响应中的一个给定字符串更改为另一个给定字符串 --with-http_dav_module 设置nginx支持通过 WebDAV 协议实现文件管理自动化。该模块处理 HTTP 和 WebDAV 方法 PUT、DELETE、MKCOL、COPY 和 MOVE。 --with-http_flv_module 基于nginx-rtmp-module的流媒体服务器，为Flash Video(FLV)文件 提供服务端伪流媒体支持通过返回以请求偏移位置开始的文件内容，该模块专门处理 在查询串中有start参数的请求, 和有预先设置到FLV头部的请求。 --with-http_mp4_module 设置nginx支持以 .mp4、.m4v、和.m4a为扩展名的文件，提供伪流媒体服务端支持。 --with-http_gunzip_module 设置nginx支持为不支持gzip编码方法的客户端解压缩响应。 --with-http_gzip_static_module 设置nginx支持允许发送文件扩展名为“.gz”的预压缩文件，而不是常规文件。 --with-http_auth_request_module 设置nginx支持根据子请求的结果实现客户端授权。 --with-http_random_index_module 设置nginx支持在文件夹中随机选择一个文件作为默认页。 --with-http_secure_link_module 设置nginx支持用于检查所请求链接的真实性，保护资源免遭未经授权的访问，并限制链接生命周期。用于检查所请求链接的真实性，保护资源免遭未经授权的访问，并限制链接生命周期。 --with-http_degradation_module 设置nginx支持degradation模块。 --with-http_slice_module 设置nginx支持将请求拆分为子请求，每个子请求返回一定范围的响应。该过滤器提供了更有效的大响应缓存。 --with-http_stub_status_module 设置nginx支持提供对基本状态信息的访问。 --with-http_perl_module 设置nginx支持perl脚本，允许在 Perl 中实现位置和变量处理程序，并将 Perl 调用插入到 SSI 中。 --with-http_perl_module=dynamic 设置nginx支持perl脚本，允许在 Perl 中实现位置和变量处理程序，并将 Perl 调用插入到 SSI 中。 --with-perl_modules_path=PATH 设置perl模块的安装路径。 --with-perl=PATH 设置Perl二进制文件路径名称。 --http-log-path=PATH 设置nginx访问日志access.log的安装路径。 --http-client-body-temp-path=PATH 设置存储http客户端请求正文临时文件的路径。可以使用client_body_temp_path指令进行更改，默认\u0026lt;prefix\u0026gt;/client_body_temp。 --http-proxy-temp-path=PATH 设置存储http代理临时文件的路径。可以使用proxy_temp_path指令进行更改，默认\u0026lt;prefix\u0026gt;/proxy_temp。 --http-fastcgi-temp-path=PATH 设置存储http fastcgi临时文件的路径。可以使用fastcgi_tmp_path指令进行更改，默认\u0026lt;prefix\u0026gt;/fastcgi_temp。 --http-uwsgi-temp-path=PATH 设置存储http uwsgi临时文件的路径。可以使用uwsgi_temp_path指令进行更改，默认\u0026lt;prefix\u0026gt;/uwsgi_temp。 --http-scgi-temp-path=PATH 设置存储http scgi临时文件的路径。可以使用scgi_temp_path指令进行更改，默认\u0026lt;prefix\u0026gt;/scgi_temp。 --with-mail 设置nginx启用 POP3/IMAP4/SMTP 邮件代理模块。 --with-mail=dynamic 设置nginx启用动态POP3/IMAP4/SMTP代理模块。 --with-mail_ssl_module 设置邮件代理服务器支持SSL/TLS协议，需要安装OpenSSL库。 --with-stream 设置nginx启用TCP/UDP(四层)代理模块。 --with-stream=dynamic 设置nginx启用动态TCP/UDP(四层)代理模块。 --with-stream_ssl_module 设置四层代理(TCP/UDP)支持SSL/TLS协议，需要安装OpenSSL库。 --with-stream_realip_module 设置nginx四层代理(TCP/UDP)支持获取客户端真实IP地址。 --with-stream_geoip_module 设置nginx四层代理支持根据客户端IP地址和预编译的MaxMind数据库创建变量。 --with-stream_geoip_module=dynamic 设置nginx四层代理支持根据客户端IP地址和预编译的MaxMind数据库动态创建变量。 --with-stream_ssl_preread_module 设置nginx四层代理支持允许在不终止 SSL/TLS 的情况下从 ClientHello 消息中提取信息。 --with-google_perftools_module 模块是用来集成Google的高性能工具集（Google Performance Tools，简称gperftools），这个工具集可以提供更好的内存和CPU性能分析。 --with-cpp_test_module 启用模块支持使用C++编写的测试代码，以便对Nginx进行单元测试和集成测试。 --add-module=PATH 设置第三方模块的安装路径。 --add-dynamic-module=PATH 设置第三方动态模块的安装路径。 --with-compat 实现动态模块兼容性。 --with-cc=PATH 设置C编译器的路径名。 --with-cpp=PATH 设置C预处理器路径名。 --with-cc-opt=OPTIONS 设置附加的C编译器选项。 --with-ld-opt=OPTIONS 设置其他链接器选项。 --with-cpu-opt=CPU 启用按指定CPU构建：pentium、pentiumpro、pentium3、pentium4、athlon、optron、sparc32、sparc64、ppc64。 --with-pcre 强制使用PCRE库。 --with-pcre=DIR 设置到PCRE库的源的路径。需要从PCRE站点下载并提取库分发。其余部分由nginx完成/配置和制作，location指令中的正则表达式支持和ngx_http_rewrite_module模块都需要该库。 --with-pcre-opt=OPTIONS 设置PCRE的其他构建选项。 --with-pcre-jit 使用JIT编译支持构建PCRE。 --with-zlib=DIR 设置zlib库源的路径。 --with-zlib-opt=OPTIONS 设置zlib其他构建选项。 --with-zlib-asm=CPU 允许使用为指定CPU之一优化的zlib汇编程序源：pentium、pentiumpro。 --with-libatomic 强制使用libatomic_ops库。 --with-libatomic=DIR 设置libatomic_ops库源的路径。 --with-openssl=DIR 设置OpenSSL库源的路径。 --with-openssl-opt=OPTIONS 设置OpenSSL其他构建选项。 --with-debug 启用nginx调试日志记录。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/configure/","section":"知识存档","summary":"configure 选项说明","title":"Nginx Configure","type":"docs"},{"content":" 针对CPU的Nginx配置优化的2个指令 处理器已进入多核时代。多内核是指在一枚处理器中集成2个或多个完整的计算引擎，多核处理器是单枚芯片。一枚多核处理器上可以承载多枚内核，但只需要单一的处理器插槽就可以工作。同时，目前流行的操作系统都已经可以利用这样的资源，将每个执行内核作为分立的逻辑处理器，通过在多个执行内核之间划分任务，在特定的时钟周期内执行更多任务，提高并行处理任务的能力。 在Nginx 配置文件中，有这两个指令: worker_processes he worker_cpu_afifinity，它们可以针对多核CPU进行配置优化。 worker_processes 指令 该指令用来设置Nginx服务器的进程数。官方文档建议设置为1即可，赋值太多会影响系统的IO效率，降低Nginx服务器的性能。 为了让多核CPU能够很好的并行处理任务，我们将worker_processes指令的赋值适当地增大一些，最好赋值为CPU的倍数。 针对双核CPU，建议设置为2或4。 worker_processes 2; worker_cpu_affinity 指令 该指令用来为每个进程分配CPU的工作内核。如下图所示，worker_cpu_affinity指令的值是由机组二进制值表示的。其中每一组代表一个进程，每组中的每一位表示该进程使用的CPU的情况，1代表使用，0代表不使用。需要注意的是，二进制位排列顺序和CPU的顺序是相反的。建议将不同的进程平均分配到不同的CPU运行内核上。 worker_cpu_affinity 指令示意图 示例，设置Nginx服务的进程数为4，CPU是4核，因此会有4组值，并且每组有4位，所以，此指令的设置为：\nworker_cpu_affinity 0001 0100 1000 0010; 4组二进制数值分别对应4个进程，第1个进程对应0001，表示使用第一个CPU内核；第2个进程对应0010，表示使用第二个CPU内核，以此类推。\n若将worker_processes指令的值赋值为8，即赋值为CPU内核个数的2倍，则worker_cpu_affinity指令的设置为：\nworker_cpu_affinity 0001 0010 0100 1000 0001 0010 0100 1000; 如果一台机器的CPU是8核CPU，并且worker_processes 指令的赋值为8，那么该指令的设置为\nworker_cpu_affinity 00000001 00000010 00001000 00010000 00100000 01000000 10000000; ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/hightconf/cpu/","section":"知识存档","summary":"针对CPU的Nginx配置优化的2个指令","title":"Nginx CPU optimization","type":"docs"},{"content":" 由ngx_http_gzip_module 模块处理的9个指令 ngx_http_gzip_module 模块主要负责Gzip功能的开启和设置，对响应数据进行在线实时压缩。 gzip 指令 该指令用于开启或者关闭Gzip功能 gzip on | off; 默认情况下，该指令设置为off，即不启用gzip功能。只有将启用该指令，下列各指令设置才有效。\ngzip_buffers 指令 该指令用于设置Gzip压缩文件使用缓存空间的大小 gzip_buffers number size; number: 指定nginx服务器需要向系统申请缓存空间的个数。\nsize: 指定每个缓存空间的大小。\n根据该配置项，Nginx服务器在对响应输出数据进行Gzip压缩时需要向系统申请number*size 大小的空间用于存储压缩数据。从Nginx 0.7.28开始，默认情况下 number * size的值为128，其中size的值取系统内存页一页的大小，为4KB或者8KB,\ngzip_buffers 32 4k | 16 8k; gzip_comp_level 指令 该指令用于设定Gzip压缩程度，包括级别1到级别9.级别1表示压缩程度最低，压缩效率最高；级别9表示压缩程度最高，压缩效率最低，最费时间。 gzip_comp_level level; 默认值设置为级别1。\ngzip_disable 指令 针对不同种类客户端发起的请求，可以选择性地开启和关闭gzip功能。该指令从Nginx0.6.23启用，用于设置一些客户端种类。Nginx服务器在响应这些种类的客户端请求时，不使用Gzip功能缓存响应输出数据。 gzip_disable regex ...; regex：根据客户端的浏览器标志(User-Agent，UA)进行设置，支持使用正则表达式。\n常见的PC浏览器及手机浏览器的UA字符串，见下表 浏览器 UA 字符串 Inernet Explorer 系列浏览器 Internet Explorer10 Mozilla/5.0(compatible;MSIE 10.0;Windows NT6.1;Trident/6.0) Internet Explorer9 Mozilla/5.0(compatible;MSIE 9.0;Windows NT6.1;Trident/5.0) Internet Explorer8 Mozilla/4.0(compatible;MSIE 8.0;Windows NT6.0;Trident/4.0) Internet Explorer7 Mozilla/4.0(compatible;MSIE 7.0;Windows NT6.0) Internet Explorer6 Mozilla/4.0(compatible;MSIE 6.0;Windows NT5.1) 火狐(FireFox)系列浏览器 Firefox7(Windows 平台) Mozilla/5.0(Windows NT6.1;Intel Mac OS X 10.6;rv7.0.1)Gecko/20100101 Firefox/7.0.1 Firefox7(Mac 平台) Mozilla/5.0(Macintosh;Intel Mac OS X 10.6;rv7.0.1)Gecko/20100101 Firefox/7.0.1 Firefox4(Windows 平台) Mozilla/5.0(Windows NT6.1;rv2.0.1)Gecko/20100101 Firefox/4.0.1 Firefox4(Mac 平台) Mozilla/5.0(Macintosh;Intel Mac OS X 10.6;rv2.0.1)Gecko/20100101 Firefox/4.0.1 谷歌(Chrom)浏览器 Chrome 10 及之前版本(Windows 平台) Mozilla/5.0(Windows;U;Windows NT5.1len-US)AppleWebKit/=version(KHTML,like Gecko)Chrome/version Safari/534.16 Chrome 10 及之前版本(Linux 平台) Mozilla/5.0(X11;U;Linux x86_64;en-US)AppleWebKit/version(KHTML,like Gecko)Chrome/version Safari/534.16 Chrome 11 (Windows 平台) Mozilla/5.0(Windows;U;Windows NT6.0;WOW64)AppleWebKit/534.24(KHTML,like Gecko)Chrome/version Safari/534.24 Chrome 11 (Linux 平台) Mozilla/5.0(X11;Linux x86_64)AppleWebKit/version(KHTML,like Gecko)Chrome/534.24 Safari/534.24 Opera 浏览器 Opera 7(Windows 平台) Opera/7.54(Windows NT 5.1;U)[en] Opera 8(Windows 平台) Opera/8.0(Windows NT 5.1;en) Opera 9(Windows 平台) Mozilla/5.0(Windows NT 5.1;U;en;rv:1.8.1)Gecko/20061208 Firefox/2.0.0.0 Opera9.50Mozilla/4.0(compatible;MSIE 6.0;Windows NT5.1;en) Opera 10(Windows 平台) Opera/9.80(Macinitosh;Intel Mac OS X;U;en)Persto/2.2.15 Version/10.00 iOS 系列平台浏览器 iOS 6 (iPhone) Mozilla/5.0(iPhone;CPU iPhone OS 6_0 like Mac OS X)AppleWebKit/536.26(KHTML,like Gecko)Version/6.0 Mobile/10A403 Safari/8536.25 iOS 6 (iPad) Mozilla/5.0(iPad;CPU iPhone OS 6_0 like Mac OS X)AppleWebKit/536.26(KHTML,like Gecko)Version/6.0 Mobile/10A403 Safari/8536.25 iOS 5 (iPhone) Mozilla/5.0(iPhone;CPU iPhone OS 5_0 like Mac OS X)AppleWebKit/534.46(KHTML,like Gecko)Version/5.1 Mobile/9A334 Safari/7534.48.3 iOS 5 (iPad) Mozilla/5.0(iPad;CPU iPhone OS 5_0 like Mac OS X)AppleWebKit/534.46(KHTML,like Gecko)Version/5.1 Mobile/9A334 Safari/7534.48.3 iOS 4 (iPhone) Mozilla/5.0(iPhone;CPU iPhone OS 4_3_2 like Mac OS X;en-us)AppleWebKit/533.17.9(KHTML,like Gecko)Version/5.0.2 Mobile/8H7 Safari/6533.18.5 iOS 4 (iPad) Mozilla/5.0(iPad;CPU iPhone OS 4_3_2 like Mac OS X;en-us)AppleWebKit/533.17.9(KHTML,like Gecko)Version/5.0.2 Mobile/8H7 Safari/6533.18.5 Android 平台浏览器 Android 4.1.2 Mozilla/5.0(Linux;U;Andriud 4.1.2;zh-cn;Nexus S Build/JZO54K)AppleWebKit/534.30(KHTML,like Gecko)Version/4.0 Mobile/8H7 Safari/534.30 Android 4.0.2 Mozilla/5.0(Linux;U;Andriud 4.0.2;en-us;Galaxy Nexus Build/ICL53F)AppleWebKit/534.30(KHTML,like Gecko)Version/4.0 Mobile/8H7 Safari/534.30 Android 2.3.6 Mozilla/5.0(Linux;U;Andriud 2.3.2;en-us;Nexus S Build/GRK39F)AppleWebKit/533.1(KHTML,like Gecko)Version/4.0 Mobile/8H7 Safari/533.1 注意： 由于浏览器的UA可以人为更改，因此对于实际情况还要进行具体分析。表格中列举的常见浏览器及UA字符串只符合默认情况。\n下面为gzip_disable指令的一个示例：\ngzip_disable MSIE [4-6].\\; 该设置使用了正则表达式，可以匹配UC字符串中包含MSIE4、MSIE5和MSIE6的所有浏览器，响应这些浏览器发出的请求时，Nginx服务器不进行GZIP压缩。\ngzip_http_version 指令 早期的一些浏览器或者HTTP客户端，可能不支持gzip自解压，因此有时会看到乱码，所以针对不同的HTTP协议版本，需要选择性地开启或者关闭gzip功能。该指令用于设置开启gzip功能的最低HTTP协议版本。 gzip_http_version 1.0 | 1.1; 设置为1.1版本，即只有客户端使用1.1及1.1以上版本的HTTP协议时，才使用gzip功能对响应输出数据进行压缩。\ngzip_min_length 指令 Gzip 压缩功能对绝大多数的压缩效果明显，但是如果压缩很小的数据，可能出现越压缩数据量越大的情况(许多压缩算法都有这样的情况发生)，因此应该根据响应页面的大小，选择性地开启或者关闭gzip功能。该指令设置页面的字节数，当响应页面的大小\u0026gt;该值时，才启用gzip功能。响应页面的大小通过HTTP响应头部中的Content-Length 指令获取，但是如果使用了Chunk编码动态压缩，Content-Length 或不存在或被忽略，该指令不起作用。 gzip_min_length 1024; 默认设置为20，设置为0时表示不管响应页面大小如何统统压缩。建议设置1KB以上，防止出现数据越压越大的情况。\ngzip_proxied 指令 该指令在使用Nginx服务器的反向代理功能时有效，前提时在后端服务器返回的响应页头部中，Request部分包含用于通知代理服务器的Via头域。它主要用于设置Nginx服务器是否对后端服务器返回的结果进行Gzip压缩。 off: 关闭Nginx 服务器对后端服务器返回结果的gzip压缩，默认设置。 expired：当后端服务器响应页头部包含用于指示响应数据过期时间的expired 头域时，启用对响应数据的gzip压缩。 no-cache：当后端服务器响应页头部包含用于通知所有缓存机制是否缓存的 Cache-Control 头域、且指令值为no-cache 时，启用对响应数据的压缩。 private：当后端服务器响应页头部包含用于通知所有缓存机制是否缓存的Cache-Control 头域、且指令值为private时，启用对响应数据的gzip压缩。 no_last_modified：当后端服务器响应页头部不包含用于指明需要获取数据最后修改时间的Last-Modified 头域时，启用对响应数据的gzip压缩。 no-etag：当后端服务器响应页头部不包含用于标示被请求变量的实体值的ETag头域时，启用对响应数据的gzip压缩。 auth：当后端服务器响应页头部包含用于标示HTTP授权证书的Authorization 头域时，启用对响应数据的gzip压缩。 any：无条件启用对后端服务器响应数据的gzip压缩。 gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...; 该指令的设置需要对HTTP协议的HTTP header 消息有基本的了解。\ngzip_types 指令 Nginx 服务器可以根据响应页的MIME类型选择性地开启gzip压缩功能。该指令用来设置MIME类型，被设置的类型将被压缩。 gzip_types mime-type ...; mime-type 变量的取值默认为text/html，但实际上，在gzip指令设置为on时，Nginx服务器会对所有的text/html 类型页面数据进行gzip压缩。该变量还可以取*值，表示对所有MIME类型的页面数据进行gzip压缩。一般情况下我们压缩常规的文件类型时，可以设置为\ngzip_types text/plain application/x-javascript text/css text/html application/xml; gzip_vary 指令 该指令用于设置在使用gzip功能时是否发送带有\u0026quot;Vary: Accept-Encoding\u0026quot;头域的响应头部。该头域的主要功能是告诉接收方发送的数据经过了压缩处理。开启后的效果是在响应头部添加了\u0026quot;Accept-Encoding：gzip\u0026quot;，这对于本身不支持gzip压缩的客户端浏览器是有用的。 gzip_vary on | off; 默认off。我们可以通过Nginx配置的add_header指令强制Nginx服务器在响应头部添加\u0026quot;Vary: Accept-Encoding\u0026quot;头域，以达到相同效果。\nadd_header Vary Accept-Encoding gzip; 该指令在使用过程中存在bug，会导致IE4及以上的浏览器的数据缓存功能失效。\n由 ngx_http_gzip_static_module 模块处理的指令 ngx_http_gzip_static_module 模块主要负责搜索和发送经过gzip功能的预压缩的数据。这些数据以.gz作为后缀名存储在服务器上。如果客户端请求的数据在之前被压缩过，且客户端浏览器支持gzip压缩，就直接返回压缩后的数据。 该模块与ngx_http_gzip_module 模块的不同之处主要在于，该模块使用的是静态压缩，在HTTP响应头部包含Cntent-Length 头域来指明报文体的长度，用于服务器可确定响应数据长度的情况；而后者默认使用Chunked 编码的动态压缩，其主要适用于服务器无法确定响应数据长度的情况，比如文件下载的情形，这时需要实时生成数据长度。 与该模块有关的指令主要有以下几个：gzip_static、gzip_http_version、 gzip_proxied、gzip_disable和gzip_vary等。 其中的gzip_static 指令，用于开启和关闭该模块的功能。 on：开启该模块的功能。 off: 关闭该模块的功能。 always：一直发送gzip预压缩文件，而不检查客户端浏览器是否支持gzip压缩。 gzip_static on | off | always; 其他指令与ngx_http_gzip_module 模块下的使用方式相同。gzip_proxied 指令只接收以下设置 gzip_proxied expired no-cacahe no-store private auth; 对于该模块下的gzip_vary指令，开启以后只给未压缩的内容添加\u0026quot;Vary: Accept-Encoding\u0026quot;头域，而不是对所有的内容都添加。如果需要给所有响应头添加该头域，可以通过Nginx配置的add_header指令实现。\n由ngx_http_gunzip_module 模块处理的2个指令 Nginx服务器支持对响应输出数据流进行Gzip压缩，这对客户端浏览器来说，需要有能力解压和处理gzip压缩数据，但如果客户端本身不支持该功能，就需要Nginx服务器在向其发送数据之前先将该数据解压。这些压缩数据可能来自于后端服务器压缩产生或者Nginx服务器预压缩产生。 Ngx_http_gunzip_module 模块便是用来针对不支持gzip压缩数据处理的客户端浏览器，对压缩数据进行解压处理的，与它有关的指令主要有以下几个：gunzip、gunzip_buffers、gzip_http_version、gzip_proxied、gzip_disable和gizp_vary等。 gunzip 指令 该指令用于开启或者关闭该模块的功能。 on: 开启该模块的功能 off: 关闭该模块的功能 gunzip_static on| off; 该指令默认off。当功能开启时，如果客户端浏览器不支持gzip处理，Nginx服务器将返回解压后的数据；如果客户端浏览器支持gzip处理，nginx服务器忽略该指令的设置，仍返回压缩数据。\n注意：\n在某些特殊情况下可能要求Nginx服务器始终返回非压缩的数据(比如使用HTTP可选模块ngx_http_addition_module时，用于在响应请求的页面开始或者结尾添加文本信息，它只有在Nginx服务器返回非压缩数据时才能正常使用)，这就需要在编译的Nginx程序之前对源码进行适当的处理。\n当客户端浏览器不支持gzip数据处理时，使用改模块可以解决数据解析的问题，同时保证Nginx服务器与后端服务器交互数据或者本身存储数据时仍然使用压缩数据，从而减少了服务器之间的数据传输量，降低了本地存储空间的和缓存的使用率。\ngunzip_buffers 指令 该指令与ngx_http_gzip_module 模块中的gzip_buffers指令非常相似，都是用于设置Nginx 服务器解压Gzip文件使用缓存空间的大小的。 number：指定Nginx服务器需要向系统申请缓存空间的个数。 size：指定每个缓存空间的大小。 gunzip_buffers number size; 根据该配置项，Nginx服务器在对Gzip数据进行减压时需向系统申请number * size大小的空间。默认情况下number * size的值为128，其中size的值取系统内存页 一页的大小，为4KB或者8KB。\ngunzip_buffers 32 4K | 16 8K; 其他指令同ngx_http_gzip_module 模块下的使用方法相同。\nGzip 压缩功能的使用 本节对两类问题进行了分析和说明，一类问题涉及客户端浏览器gzip压缩功能的支持，另一类问题涉及Nginx服务器作为代理服务器时与其他服务器在交互过程中gzip压缩功能的支持。 gzip 压缩功能综合配置实例 user nobody nobody; worker_processes 3; error_log logs/error.log; pid nginx.pid; events { use epoll; worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sedfile on; keepalive_timeout 65; log_format access.log \u0026#39;$remote_addr-[$time_local]-\u0026#34;$request\u0026#34;-\u0026#34;$http_user_agent\u0026#34;\u0026#39;; gzip on; # 开启gzip功能 gzip_min_length 1024; # 响应页数据上限 gzip_buffers 4 16k; # 缓存空间大小 gzip_comp_level 2; # 压缩机别为2 gzip_types text/pain application/x-javascript text/css application/xml; # 压缩源文件类型 gzip_vary on; # 启用压缩标识 gunzip_static on; # 检查预压缩文件 server { listen 8081; server_name myserver1; access_log /myweb/server1/log/access.log; error_page 404 /404.html; location /server1/location1 { root /myweb; index index.svr1-loc1.htm; } location /server1/location2 { root /myweb; index index.svr1-loc2.htm; } } server { listen 8082; server_name 192.168.1.3; access_log /myweb/server2/log/access.log; error_page 404 /404.html; location /server2/location1 { root /myweb; index index.svr2.loc1.htm; } location /server2/location2 { root /myweb; index index.svr2.loc2.htm; } location = /404.html { root /myweb; index 404.html; } } } 在该实例中，配置开启gzip功能(代码：gzip_min_length 1024)，Nginx服务器用于gzip压缩的缓存空间大小为4 X 16KB = 64KB (代码：gzip_buffers 4 16K)。当响应页数据大于1KB时(代码：gzip_min_length 1024行)对类型为TXT数据、JS数据、CSS数据和XML数据(代码：gzip_types text/plain application/x-javascript text/css application/xml)进行级别为2 的快速Gzip压缩(代码：gzip_comp_level 2)，并在返回数据头部添加“Vary：Accept-Encoding”头域通知客户端浏览器使用了gzip压缩(代码：gzip_vary on)。如果检测到客户端浏览器不支持gzip压缩功能，Nginx服务器自动将预压缩过的数据解压后再发送。\n为了使Nginx服务器能够在全局范围内应用gzip压缩功能，应放到HTTP全局块里。如果要对各个虚拟主机差别性对待，可以在对应的server块中添加各自的gzip配置指令，对于少数虚拟主机的差别性对待，也可以在HTTP全局块中配置gzip指令后在对应的少数server块中添加配置。比如，在上个例子中，假设需要设置虚拟主机192.168.1.3不开启gzip压缩功能，如下所示\nserver { listen 8082; server_name 192.168.1.3; gzip off; access_log /myweb/server2/log/access.log error_page 404 /404.html; } HTTP块中的gzip配置不需要改动。\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/gzip/","section":"知识存档","summary":"介绍gzip相关的指令配置及功能的使用。","title":"Nginx 服务器的 GZIP 压缩","type":"docs"},{"content":" Nginx 的功能特性 Nginx提供的基本功能从大体上归纳为基本的HTTP服务、高级HTTP服务和邮件服务等三大类。 基本HTTP服务 Nginx提供基本HTTP服务，可以作为HTTP代理服务器和反向代理服务器，支持通过缓存加速访问，可以完成简单的负载均衡和容错，支持包过滤功能，支持SSL等。 在Nginx提供的基本HTTP服务中，主要包含以下功能特性：\n处理静态文件(如HTML静态网页及请求)；处理索引文件以及支持自动索引。 打开并自行管理文件描述符缓存。 提供反向代理服务，并且可以使用缓存加速反向代理，同时完成简单负载均衡及容错。 提供远程FastCGI服务的缓存机制，加速访问，同时完成简单的负载均衡及容错。 使用 Nginx的模块化特性提供过滤器功能。Nginx基本过滤器包括Gzip压缩、ranges支持、chunked响应、XSLT、SSI以及图像缩放功能等。其中，针对包含多个SSI的页面，经由FastCGI或反向代理，SSI过滤器可以并行处理。 支持HTTP下的安全套接层安全协议SSL。 高级HTTP服务 在Nginx提供的高级HTTP服务中，主要包含以下功能特性：\n支持基于名字和IP的虚拟主机配置。 支持HTTP/1.0中的keep-alive模式和管线(PipLined)模型连接。 支持重新加载配置以及在线升级时，无须中断正在处理的请求。 自定义访问日志格式、带缓存的日志写操作以及快速日志轮转。 提供3xx ~ 5xx错误代码重定向功能。 支持重写(Rewrite)模块扩展。 支持HTTP DAV模块，从而为HTTP WebDAV提供PUT、DELETE、MKCOL、COPY以及MOVE方法。 支持FLV流和MP4流传输。 支持网络监控，包括基于客户端IP地址和HTTP基本认证机制的访问控制、速度限制】来自同一地址的同时连接数或请求数限制等。 支持嵌入Perl语言。 邮件代理服务 Nginx提供邮件代理服务也是其基本开发需求之一，主要包含以下功能特性：\n支持使用外部HTTP认证服务器重定向用户到IMAP/POP3后端，并支持IMAP认证方式(LOGIN、AUTH LOGIN/PLAIN/CRAM-MD5)和POP3认证方式(USER/PASS、APOP、AUTH LOGIN/PLAIN/CRAM-MD5)。 支持使用外部HTTP认证服务器认证用户后重定向连接到内部SMTP后端，并支持SMTP认证方式(AUTH LOGIN/PLAIN/CRAM-M5)。 支持邮件代理服务器下的安全套接层安全协议SSL。 支持纯文本通信协议的扩展协议STARTTLS。 HTTP 代理和反向代理 代理服务器和反向代理服务是Nginx服务器作为Web服务器的主要功能之一，尤其是反向代理服务，是应用 十分广泛的功能。 在提供反向代理服务方面，Nginx服务器转发前端请求性能稳定，并且后端转发与业务配置相互分离，配 置相当灵活。在进行Nginx服务器配置时，配置后端转发请求完全不用关心网络环境如何，可以指定任意的IP地址和端口号，或其他类型的链接、请求等。\nNginx 服务器的反向代理服务功能并不只有这些，提供的配套功能相当丰富。首先，它支持判断表达式。 通过使用正则表达式进行相关配置，可以实现根据不同的表达式，采取不同的转发策略。其次，它对后端返回情况进行了异常判断，如何返回结果不正常，则重新请求另一台主机(即将前端请求转向另一后端IP)，并自动剔除返回异常的主机。它还支持错误页面跳转功能。\n负载均衡 负载均衡，一般包含两方面的含义。一方面是，将单一的重负载分担到多个网络节点上做并行处理，每个 节点处理结束后将结果汇总返回给用户，这样可以大幅提高网络系统的处理能力；第二个方面的含义是，将大量的前端并发访问或数据流量分担到多个后端网络节点上分别处理，这样可以有效减少前端用户等待响应的时间。Web服务器、FTP服务器、企业关键应用服务器等网络应用方面谈到的负载均衡问题，基本隶属于后一方面的含义。因此，Nginx服务器的负载均衡主要是对大量前端访问和流量进行分流，以保证前端用户访问效率。在绝大多数的Nginx应用中，都会或多或少涉及它的负载均衡服务。\nNginx 服务器的负载均衡策略可以划分为两大类：即内置策略和扩展策略。内置策略主要包含轮询、加权 轮询和IP hash三种；扩展策略主要通过第三方模块实现，种类比较丰富，常见的有url hash、fair等。\n在默认情况下，内置策略会被编译进Nginx内核，使用时只需要在Nginx服务器配置中设置相关参数即可。扩展策略不会编译进Nginx内核，需要手动将第三方模块编译到Nginx内核。\n负载均衡策略实现原理 轮询策略： 就是将每个前端请求按顺序(时间顺序或排列次序)逐一分配到不同的后端节点上，对于出现问题的后端节点自动排除。\n加权轮询策略： 就是在基本的轮询策略上考虑后端节点接受请求的权重，指定各后端节点被轮询的几率。加权轮询策略主要用于后端节点性能不均的情况。根据后端节点性能的实际情况。我们可以在Nginx服务器的配置文件中调整权重值，使得整个网络对前端请求达到最佳的响应能力。\nIP hash策略: 是将前端的访问IP进行hash操作，然后根据hash结果将请求分配给不同的后端节点。这种策略可以看作是一种特殊的轮询策略。通过Nginx的实现，每个前端访问IP会固定访问一个后端节点。这样做的好处是避免考虑前端用户的session在后端多个节点上共享的问题。\nurl hash策略： 扩展中的url hash在形式上和ip hash相近，不同之处在于，IP hash策略是对前端访问IP进行hash操作，而url hash策略是对前端请求的url 进行了hash操作。url hash策略的有点在于，如果后端有缓存服务器，它能够提高缓存效率，同时也解决了session的问题；缺点是，如果后端节点出现异常，它不能自动排除该节点。在实际使用过程中发现，后端节点出现异常会导致Nginx服务器返回503错误。\nfair策略： 扩展的第三方模块fair则是从另一个角度来实现Nginx服务器负载均衡策略的。该模块将前端请求转发到一个最近负载最小的后台节点。那么，负载最小怎么判断呢？ Nginx通过后端节点对请求的响应时间来判断负载情况。响应时间短的节点负载相对就轻。得出判断后，Nginx就将前端请求转发到选中的负载最轻的节点。\nWeb 缓存 Squid在Web服务器领域中是一款相当流行的开源代理服务器和Web缓存服务器。作为网页服务器的前端 缓存服务器，在很多优秀的站点中，它被用以缓存前端请求，从而提高Web服务器的性能，它还可以缓存万维网、域名系统或者其他网络搜索等，为一个集体提供网络资源共享服务。 Nginx服务器从0.7.48版本开始，也支持了和squid类似的缓存功能。 Nginx服务器的Web缓存服务主要由proxy_cache相关指令集和fastcgi_cache相关指令集构成。其 中，proxy_cache主要用于在Nginx服务器提供反向代理服务时，对后端资源服务器的返回内容进行URL缓存；fastcgi_cache主要用于对FastCGI的动态程序进行缓存。另外还有一款常用的第三方模块ngx_cache_purge也是Nginx服务器Web缓存功能中经常用到的。它主要用于清除Nginx服务器上指定的URL缓存。\n到Ngnx 0.8.32版本，proxy_cacahe和fastcgi_cache两部分的功能已经比较完善，再配合第三方 的ngx_cache_purge模块，Nginx服务器已经具备了Squid所拥有的Web缓存加速功能和清除指定URL缓存的功能；同时，Nginx服务器对多核CPU的调度比Squid更胜一筹，性能高于Squid，而在反向代理，负载均衡代理等其他方面，Nginx也不逊于Squid。这使得Nginx服务器可以同时作为负载均衡服务器和Web缓存服务器来使用，基本可以取代Squid。\n","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/function/","section":"知识存档","summary":"Nginx的功能特性介绍","title":"Nginx Funciton","type":"docs"},{"content":" 针对IPv4的内核7个参数的配置优化 这里提及的参数是和IPv4 网络有关的Linux内核参数。可以将这些内核参数的值追加到Linux系统的/etc/sysctl.conf 文件中，然后使用以下命令使修改生效。\n#/sbin/sysctl -p net.core.netdev_max_backlog 参数 表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目。一般默认值为128(可能不同的Linux系统该数值也不同)。Nginx 服务器中定义的NGX_LISTEN_BACKLOG默认为511。 net.core.netdev_max_backlog = 262144 net.core.somaxconn 参数 该参数用于调节系统同时发起的TCP连接数，一般默认为128。在客户端存在高并发请求的情况下，该默认值较小，可能导致链接超时或者重传问题，可以根据实际需要结合并发请求数来调节此值。 net.core.somaxconn = 262144 net.ipv4.tcp_max_orphans 参数 该参数用于设定系统中最多允许存在多少TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，没有与用户文件句柄关联的TCP套接字将立即被复位，同时给出警告信息。这个限制只是为了防止简单的DoS(Denial of Service，拒绝服务)攻击。一般在系统内存比较充足的情况下，可以增大这个参数的赋值。 net.ipv4.tcp_max_orphans = 262144 net.ipv4.tcp_max_syn_backlog 参数 该参数用于记录尚未收到客户端确认信息的连接请求的最大值。对于拥有128MB内存的系统而言，此参数的默认值是1024，对小内存的系统则是128。一般在系统内存比较充足的情况下，可以增大这个参数的赋值。 net.ipv4.tcp_max_syn_backlog = 262144 net.ipv4.tcp_timestamps 参数 该参数用于设置时间戳，这可以避免序列号的卷绕。在一个1Gb/s 的链路上，遇到以前用过的序列号的概率很大。当此值赋值为0时，禁用对于TCP时间戳的支持。在默认情况下，TCP协议会让内核接受这种\u0026quot;异常\u0026quot;的数据包。针对Nginx 服务器来说，建议关闭。 net.ipv4.tcp_timestamps = 0 net.ipv4.tcp_synack_retries 参数 该参数用于设置内核放弃TCP连接之前向客户端发送SYN+ACK包的数量。为了建立对端的连接服务，服务器和客户端需要进行三次握手，第二次握手期间，内核需要发送SYN并附带一个会应前一个SYN的ACK，这个参数主要影响这个过程，一般赋值为1，即内核放弃连接之前发送依次SYN+ACK包，可以设置为 net.ipv4.tcp_synack_retries = 1 net.ipv4.tcp_syn_retries 参数 该参数的作用与上一个参数类似，设置内核放弃建立连接之前发送SYN包的数量，它的赋值和上个参数一样即可。 net.ipv4.tcp_syn_retries = 1 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/nginx/hightconf/ipv4/","section":"知识存档","summary":"针对IPv4的内核7个参数的配置优化","title":"Nginx Kernel optimization","type":"docs"},{"content":" 前言 市面上有很多开源的静态站点，最早使用的是 WordPress, Typecho, 有好看的主题，有后台管理，可以在线编辑发布，对新手非常友好。就是比较折腾，nginx+php+mysql部署 后期维护比较麻烦，也需要花费一笔费用在服务器上。 后来换成了 Hexo, 免费，开源，无需服务器，托管到GitHub上就行。由于hexo基于nodejs,很多依赖关系导致的bug无从修复，至此放弃。 一直探索，直至发现了 Hugo Hugo 介绍 Hugo 是开源的静态站点生成器之一，使用go语言开发，将Markdown文件转变成html，是世界上最快的网站搭建框架。 纯静态页面，访问速度快，而且安全。不足的地方就是跟用户的交互功能需要借助第三方插件来完成，例如评论，访问统计等。 完全跨平台，可在 macOS、Linux、Windows 等上轻松安装与使用。 博客安装思路 了解系统的终端命令使用，不同系统的终端命令也不是完全相同。 例如：ls、cd 安装Git，会 Git 命令的基本使用。 有 GitHub账户, 以及以github账户开头的github仓库，例如: username.github.io, username必须是 github 账户名称。 了解 GitHub Action 持续集成和持续交付平台，以及基本语法。 默认仓库主分支名称为main,还需创建一个分支，命名为 gh-pages 切换到这个分支上。 Hugo 安装 我这边使用Linux系统安装，不同操作系统的安装可以参考 Hugo Install, 以及想要安装的 Hugo Version 我安装的Hugo版本为 v0.100.0 hugo new site myblog 查看Hugo是否安装成功，可以使用以下命令, 有版本号出现就代表安装成功。 hugo-100 version hugo v0.100.0-27b077544d8efeb85867cb4cfb941747d104f765 linux/amd64 BuildDate=2022-05-31T08:37:12Z VendorInfo=gohugoio Blowfish 主题安装 这里 Hugo Theme 有很多主题可选择任意一个喜欢的应用到网站中。 我这边选的是 Blowfish, 这个主题对Hugo的版本要求为 \u0026gt; v0.87.0 # 进入博客目录下 cd myblog # 初始化git git init # 下载主题 git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish # 若下载失败可以换成 git clone 尝试 git clone https://github.com/nunocoracao/blowfish.git themes/blowfish 配置网站url,将主题目录下的配置文件config 复制到当前位置。cp -r theme/blowfish/exampleSite/config . 这个config目录下默认有6个配置文件，我们只需要配置config.toml的baseURL参数即可 cd config/_default/ vim config.toml baseURL = \u0026#34;https://yourname.github.io/\u0026#34; # 网站根目录的url,将你的域名，或者是GitHub Pages 指定的仓库名写上即可。 # googleAnalytics = \u0026#34;G-PEDMYR1V0K\u0026#34; # 这个参数需要注释掉。 网站构建编译 在推送博客前可以先预览构建效果，满意之后再进行推送。这样可以避免一些效果不达标的结果，减少推送次数 hugo server -D -F --minify --bind=0.0.0.0 # 这样就可以使用本机外网ip进行访问了，htp://ipaddr:1313 达到预期后构建编译，此时，public目录下就产生了网页静态文件。 hugo --minify Github Pages 介绍 GitHub Pages 是从 GitHub 上的存储库获取HTML、CSS和JavaScript文件，可以选择通过构建过程运行文件，然后发布网站。 Github Actions 介绍 GitHub Actions 是一个持续集成和持续交付 (CI/CD) 平台，可以自动化构建、测试和部署管道 创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境 推送博客至GitHub 推送前的准备工作，需要申请两个秘钥，一个用于ssh免密登录github，一个授权github Action 仓库读取的秘钥。 因为本地Git与GitHub之间数据传输是通过ssh秘钥进行的，创建秘钥并关联GitHub仓库 # 关联远程github账户 git config --global user.email \u0026#34;your@example.com\u0026#34; # github邮件 git config --global user.name \u0026#34;Your UserName\u0026#34; # GitHub账户名称 # 创建秘钥文件 ssh-keygen -t rsa -b 2048 -C \u0026#34;youremail@example.com\u0026#34; -f ~/.ssh/filename # 会产生一个公钥和一个私钥文件放在 ~/.ssh/ filename.pub # 公钥 filename.rsa # 私钥 # 回到GitHub账户，右上角点击头像---\u0026gt;Settings---\u0026gt;然后找到 SSH and GPG keys ---\u0026gt;点击 New SSH key # title 随意写，自己清楚就行，将复制的内容粘贴到key中，Add SSH key即可。 验证是否可以免密登录github ssh-T git@github.com Hi UserName/UserName.github.io! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 配置授权 github Action 秘钥读取仓库的权限。 在 GitHub账户上，点击头像\u0026mdash;\u0026gt; Settings \u0026mdash;\u0026gt; Developer settings \u0026mdash;\u0026gt; Personal access tokens \u0026mdash;\u0026gt; Generate new key \u0026mdash;\u0026gt; Tokens (classic)\nnote描述：就是写token是干嘛。 然后选择个人令牌的访问权限，按需选择即可\n我的选择范围： [repo admin:repo_hook delete_repo]\n生成一个新的令牌，需要注意，新令牌的token只展示一次，需要复制下来\n进入yourname.github.io仓库 \u0026mdash;\u0026gt; Settings \u0026mdash;\u0026gt; Secrets and variables \u0026mdash;\u0026gt; Action \u0026mdash;\u0026gt; New repository secret\nname: 密钥名称 ACCESS_TOKEN secret： 将刚刚复制的token粘贴到这里 添加密钥(add secret)\n配置自动化工作流程，使博客每次更新推送时可自动触发CI/CD 自动部署网站。 mkdir -p .github/worker touch .github/worker/gh-pages.yml # gh-pages.yaml 文件内容 name: GitHub Pages on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.BLOWFISH_TOKEN }} # 授权秘钥填写位置 publish_branch: gh-pages publist_dir: ./public cname: yourdomain 推送至GitHub git remote add origin git@github.com:username/uername.github.io.git # 关联远程仓库 git add . # 提交到暂存库，反悔可 git reset 撤销 git commit -m \u0026#34;message\u0026#34; # 提交至本地仓库，message 就是写这个版本做了什么修改 git push origin main # 推送至远程仓库。 ","date":"January 1, 1","externalUrl":"","permalink":"/docs/theme/threshold/","section":"知识存档","summary":"使用Linux结合GitHub+hugo+blowfish搭建个人博客网站","title":"搭建个人博客","type":"docs"},{"content":" Nginx是一个免费、开源、高性能的HTTP服务器和反向代理服务器，以及IMAP/POP3代理服务器。\nNginx服务器功能非常丰富，支持FastCGI、SSL、Virtual Host、URL Rewrite、HTTP Basic Auth、Gzip等大量使用功能；并且支持更多的第三方功能模块的扩展。\n","date":"April 12, 2024","externalUrl":null,"permalink":"/docs/nginx/","section":"知识存档","summary":"Nginx是一个免费、开源、高性能的HTTP服务器和反向代理服务器，以及IMAP/POP3代理服务器。","title":"Nginx","type":"docs"},{"content":" ","date":"April 12, 2024","externalUrl":null,"permalink":"/","section":"小橘子Single","summary":" ","title":"小橘子Single","type":"page"},{"content":"","date":"April 12, 2024","externalUrl":null,"permalink":"/docs/","section":"知识存档","summary":"","title":"知识存档","type":"docs"},{"content":"","date":"March 26, 2024","externalUrl":null,"permalink":"/shcode/","section":"Shcodes","summary":"","title":"Shcodes","type":"shcode"},{"content":"","date":"March 19, 2024","externalUrl":null,"permalink":"/tags/friends/","section":"Tags","summary":"","title":"friends","type":"tags"},{"content":"","date":"March 19, 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"March 19, 2024","externalUrl":null,"permalink":"/about/","section":"关于","summary":"","title":"关于","type":"about"},{"content":"感谢🙏 金圣皓博主提供的友联，简洁干净。\n友联把遥远的距离汇聚在一起。\nFollw me 金圣皓 我喜欢听花开的声音，更想自由地深情地呼吸 Yuepu`s Blog 保持独立思考，不急，但是不停~ 草方块 还没取正经名字的折腾怪物 BinaryDigit My digital home for hobbies and notes 春江花朝秋月夜 我一直在寻找着什么，寻找着某个人。 ","date":"March 19, 2024","externalUrl":null,"permalink":"/about/friends/","section":"关于","summary":"来自世界各地的博主朋友们","title":"友链","type":"about"},{"content":"","date":"March 1, 2022","externalUrl":null,"permalink":"/tags/nginx/","section":"Tags","summary":"","title":"nginx","type":"tags"},{"content":" 执行这条命令的是希望nginx不停止服务的情况下把旧的nginx配置文件内容平滑的更新为新的配置文件内容。\nnginx -s reload 流程 因为启动nginx服务有两个进程,一个是master进程，一个是worker进程 worker 进程 是由nginx配置文件的worker_processes配置参数控制的，表示CPU处理核数 [1] 向master 进程发送 HUP 信号 [2] master 进程校验nginx配置文件语法是否正确 [3] master 进程打开新的监听端口 [4] master 进程用新的nginx配置启动新的 worker 子进程 [5] master 进程向老的 worker 子进程 发送 QUIT 信号 [6] 老的 worker 子进程关闭监听句柄，处理完当前连接后结束进程 流程图 flowchart TD a([正在运行的nginx服务]) a1[master进程\\nWorker进程] b[修改nginx配置文件] c[尝试配置,尝试打开日志文件,\\n尝试分配新的监听端口] d{是否成功} d1[回滚配置] d2[使用新的配置,新建一个Worker进程,\\n新建成功后发送一个关闭消息给旧的Worker进程] e[旧的Worker进程 收到信号后会继续服务,\\n当所有请求的客户端被服务后,旧进程关闭] f([结束]) a --\u003e|启动| a1 a --\u003e|update| b --\u003e c --\u003e d d --\u003e|否| d1 --\u003e f d --\u003e|是|d2 --\u003e e --\u003e f ","date":"March 1, 2022","externalUrl":"","permalink":"/posts/nginx-reload/","section":"笔记","summary":"记录nginx reload的过程","title":"nginx-reload原理","type":"posts"},{"content":"分享知识，点亮世界。\n","date":"March 1, 2022","externalUrl":null,"permalink":"/posts/","section":"笔记","summary":"分享知识，点亮世界。","title":"笔记","type":"posts"},{"content":" Session与Cookie详解 session 与 cookie 是什么？ session 与cookie 是属于一种会话控制技术，常用在身份识别，登录验证，数据传输等。 举个例子：就像我们去超市买东西结账的时候，我们要拿出我们的会员卡才会获取优惠.这时候，我们怎么识别这个会员卡真实有效的呢?当我们将会员号给到收银员，收银员根据我们提供的会员号，输入到系统中，系统根据这个会员号去查询，如果查询到了就证明这个会员号是真实存在的.这里的会员号就好比cookie与session.会员系统就好比服务器端，收银员就好比客户端. 为什么会用到session与cookie？ 这里有必要了解一下http应用传输协议的特点了。由于http协议是无状态的，即浏览器去请求了一个网页，这时候就是一个http请求，当服务端接收到请求之后，返回客户端需要的数据，在这过程中浏览器与服务器是建立了一个连接的。但是当服务端返回数据，客户端收到数据之后，他们的这种连接关系就断开了。下次浏览器再去发送请求的时候，又是重新建立一个连接，这两个链接没有任何关系。试想一下，当我们登录一个商场系统的时候，进入首页做了登录操作，但是我们下单或者加入购物车的时候，还需要登录，每访问一个页面就要登录，是不是很繁琐同时也是很不科学的，万一我们加入购物车的商品，我们点击下单了，下单页面要登录而且还无法正确的反馈出你下单时的那些商品。 Http特点 http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。 无连接。所谓的无连接就是服务器收到了客户端的请求之后，响应完成并收到客户端的应答之后，即断开连接。限制每次的连接只处理一次请求。从而节省传输时间。 无状态。http协议对事务的处理没有记忆能力。也就意味着如果需要前面的信息，只能重传，这无形之中增加数据的传输量。这种方式某种方面上讲解放了服务器，但是却不利于客户端与服务器的连接。为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session 简单快捷：所谓的简单快捷是指客户端向服务器请求服务时，一般来说只需要传输请求方法和路径，就能进行访问 灵活：这里主要指的是客户端可以通过http协议传输任意类型的数据。比如传输.jpg文件、.ppt文件等等，只需要设定content-type就可以进行传输。 Session Session是指一个终端用户与交互系统进行通信的时间间隔，通常指从注册进入系统到注销退出系统之间所经过的时间。以及如果需要的话，可能还有一定的操作空间。 一个Session的概念需要包括特定的客户端，特定的服务器端以及不中断的操作时间。A用户和C服务器建立连接时所处的Session同B用户和C服务器建立连接时所处的Session是两个不同的Session。 Session的工作原理 当一个session第一次被启用时，一个独一的标识被存储于本地的cookie中. 首先使用session_start()函数，PHP从session仓库中加载已经存储的session变量。 当执行PHP脚本时，通过使用session_register()函数注册session变量。 当PHP脚本执行结束时，未被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php.ini文件中的session.save_path指定，下次浏览网页时可以加载使用。 Session的运行原理 客户端向服务端发起请求，建立通信 服务端根据设置的Session创建指令，在服务端创建一个编号为SessionID的文件，里面的值就是Session具体的值(组成部分 变量名 | 类型 :长度:值). 服务端将创建好的sessionid编号响应给客户端，客户则将该编号存在cookie中(一般我们在浏览器存储的调试栏中会发现cookie中有一个PHPSESSID的键，这就是SessionID，当然这个名称，我可以通过设置服务端是可以改变的). 当下一次请求时，客户端将这个sessionid携带在请求中，发送给服务端，服务端根据这个sessionid来做一些业务判断. Session的存储机制 存储方式: session默认是文件存储的.我们可以通过php.ini的配置来设置存储驱动传送门。 生命周期: 当我们未设置session的生命周期时，当浏览器关闭之后存储在客户端的phpsessid自动消失，因为它是存在内存，下次建立连接的时候会重新创建一个phpsessid.之前的session，PHP会自动的根据垃圾回收机制自动删除.这里我们可以根据session_set_cookie_params($expire)函数来设置一个生命周期. Session的使用场景 用户身份识别 数据传输 登录控制(是否登录,单点登录) Session的特点: 不是线程安全的，应该避免多个线程共享同一个Session实例； Session实例是轻量级的，所谓轻量级：是指他的创建和删除不需要消耗太多资源； Session对象内部有一个缓存，被称为Hibernate第一缓存，他存放被当前工作单元中加载的对象，每个Session实例都有自己的缓存。 Session的注意事项 安全性: sessionid是按照一定的算法生成，要保证session的值唯一性和随机性 客户端禁用cookie，根据上面session的运行原理可以得出，session的存储于传送还是依赖于客户端，因此当客户端禁用cookie时，客户端是无法保存PHPSESSID的，这时候可以通过url重写或者表单来实现session的传输. Cookie cookie是远程浏览器存储数据以此追踪用户和识别用户的的机制，从实现来说，cookie是存储在客户端上的一个数据片段(即保存在客户机中的一个简单的文本文件) Cookie 客户端向服务端发起一个http请求. 服务端设置一个创建cookie的指令，响应给客户端 客户端收到服务端响应的指令，根据指令在客户端创建一个cookie 当下一次请求时，客户端携带这个cookie向服务端发送请求. 存储机制 cookie在客户端存储的形式有三种,不同的浏览器的存储机制不同，存的cookie也不同。 文件存储: 浏览器会针对不同的域，在磁盘的对应目录创建一个单独的文件，来存储该域下面的cookie值. 内存存储: 当浏览器关闭时，该cookie随之消失.根据下面的创建语法，当我们未设置过期时间时则会出现这种情况 flash存储: 这种存储方式是永久存储在磁盘中，即使通过浏览器删除一些数据都是无法删除该方式存储的cookie，如果需要删除，可能通过磁盘的方式 Cokie的应用 用户身份识别 数据传输 登录控制(是否登录、单点登录) Session与Cookie的区别 Session存储在服务端，Cookie存储在客户端。 Cookie的创建指令由服务端设置 Session的SessionID需要客户端存储 cookie与session的几个误区 客户端禁止cookie，session无法使用？ 使用url重写或者表单提交可以实现. session和cookie的安全性比较，session存在客户端安全更高? 由于cookie是存在客户端的，相对来说安全性是要低一些，不过在创建的时候可以设置$httpOnly值. 由于cookie与session是相互关联的，获取到cookie一定程度上获取到了session，同样可以操作session. cookie与session是不是在浏览器关闭的时候会消失? 这需要查看存储机制了。cookie可以存文件，内存，flash.存内存当然浏览器关闭则消失了；session由于垃圾回收机制，当在垃圾回收机制内是不会删除的，除非你代码中显示的做了删除操作. cookie是存储在客户端中，如何增加其安全性? 我们可以在设置cookie的时候，增加一些特殊参数，如客户端信息ip、浏览器信息等. 当cookie存在客户端的文件中，是不是每个浏览器获取到这个文件都可以进行操作? 要看浏览器之间对cookie的管理机制是不是一样. ","date":"January 30, 2022","externalUrl":"","permalink":"/posts/session-cookie/","section":"笔记","summary":"ession和cookie的作用","title":"session与cookie详解","type":"posts"},{"content":" 系统 不同系统间存在差异 例如：centos系统7和8 ]# cat /etc/centos-release CentOS Linux release 7.6.1810 (Core) ]# ls /etc/hosts.deny /etc/hosts.deny # 可以理解为ssh登录黑名单文件，8版本没有 # 文件记录格式： sshd: ipaddr /var/log/secure 记录ssh登录失败的IP，过滤100条看看 ]# tail -n 100 /var/log/secure | awk \u0026#39;/Failed password/{print $0}\u0026#39; Mar 18 23:04:37 centos sshd[31222]: Failed password for invalid user zywang from 165.232.124.55 port 48182 ssh2 Mar 18 23:04:37 centos sshd[31225]: Failed password for invalid user zyx from 165.232.124.55 port 48214 ssh2 Mar 18 23:04:37 centos sshd[31233]: Failed password for invalid user zz from 165.232.124.55 port 48342 ssh2 Mar 18 23:04:37 centos sshd[31228]: Failed password for invalid user zyx from 165.232.124.55 port 48246 ssh2 Mar 18 23:04:38 centos sshd[31235]: Failed password for invalid user zzwang from 165.232.124.55 port 48374 ssh2 Mar 18 23:04:38 centos sshd[31221]: Failed password for invalid user zyliu from 165.232.124.55 port 48150 ssh2 Mar 18 23:04:38 centos sshd[31231]: Failed password for invalid user zy from 165.232.124.55 port 48310 ssh2 Mar 18 23:04:38 centos sshd[31238]: Failed password for invalid user zzy from 165.232.124.55 port 48438 ssh2 Mar 18 23:04:39 centos sshd[31242]: Failed password for invalid user zz from 165.232.124.55 port 48502 ssh2 Mar 18 23:04:40 centos sshd[31240]: Failed password for invalid user zzy from 165.232.124.55 port 48470 ssh2 ssh防爆破脚本 #!/bin/bash # ssh 防爆破,登录失败超过3次就禁止登录 set -e secure_file=($(ls /var/log/secure* | grep -v \u0026#34;gz$\u0026#34;)) sfn=${#secure_file[@]} logfile=\u0026#34;/tmp/tmp.txt\u0026#34; for ((file=0;file\u0026lt;\u0026#34;$sfn\u0026#34;;file++)) do awk \u0026#39;/Invalid user/{print $(NF-2)}\u0026#39; \u0026#34;${secure_file[file]}\u0026#34; | awk \u0026#39;{ip[$1]++;}END{for(i in ip){print ip[i],i}}\u0026#39; | awk \u0026#39;$1\u0026gt;3{print $0}\u0026#39; \u0026gt;\u0026gt; \u0026#34;$logfile\u0026#34; done [ -s \u0026#34;$logfile\u0026#34; ] \u0026amp;\u0026amp; while read count sship do if [ $(grep -c \u0026#34;sshd:$sship\u0026#34; /etc/hosts.deny) -eq 0 ];then echo \u0026#34;sshd:$sship\u0026#34; \u0026gt;\u0026gt; /etc/hosts.deny time=$(date \u0026#34;+%Y-%m-%d %H:%M\u0026#34;) curl -s --retry 3 https://cip.cc/$sship | grep -E \u0026#34;IP|运营商|数据二|数据三\u0026#34; | awk -v time=\u0026#34;$time\u0026#34; -v count=\u0026#34;$count\u0026#34; \u0026#39;BEGIN{print \u0026#34;===============================\u0026#34;;print \u0026#34;时间 :\u0026#34;,time;print \u0026#34;次数 :\u0026#34;,count}$3!=\u0026#34;\u0026#34;{print $0}END{print \u0026#34;备注 ：已限制ssh连接\u0026#34;}\u0026#39; | sed \u0026#39;s/数据二/地址一/\u0026#39; | sed \u0026#39;s/数据三/地址二/\u0026#39; \u0026gt;\u0026gt; /tmp/sshd.log fi done \u0026lt; \u0026#34;$logfile\u0026#34; \u0026gt; \u0026#34;$logfile\u0026#34; 给脚本加上执行权限 ]# chmod +x secure.sh 放入cron 计划任务里 */60 * * * * root /usr/bin/sh /opt/secure.sh # 一个小时执行一次 测试一段时间的效果 ]# cat /tmp/ssh.log =============================== 时间 : 2022-02-16 17:43 次数 : 2274 IP : 159.89.224.4 运营商 : digitalocean.com 地址一 : 美国 | 纽约DigitalOcean数据中心 地址二 : 美国纽约纽约 备注 ：已限制ssh连接 =============================== 时间 : 2022-02-16 17:43 次数 : 4639 IP : 206.189.190.8 运营商 : digitalocean.com 地址一 : 美国 地址二 : 美国纽约纽约 备注 ：已限制ssh连接 =============================== 时间 : 2022-03-03 00:01 次数 : 15371 IP : 137.184.230.247 地址一 : 美国 地址二 : 美国俄亥俄辛辛那提 备注 ：已限制ssh连接 =============================== ","date":"December 9, 2021","externalUrl":"","permalink":"/posts/ssh-script/","section":"笔记","summary":"保障ssh远程登陆安全","title":"ssh防爆破","type":"posts"},{"content":" code-server简介 vscode 是一款轻量级但功能强大的源代码编辑器,适用于 Windows、macOS 和 Linux。 支持C++、C#、Java、Python、PHP、Go等等众多语言。 致力于在任何地方的任何机器上运行VS Code并在浏览器中访问它。 官方文档： code-server 软件包： code-server 服务器要求 1 GB 内存 2 个 CPU 内核 环境必须启用 WebSockets，因为代码服务器使用 WebSockets 在浏览器和服务器之间进行通信。 吞吐量 读取：3000 IOPS，50 MB/s 写入：3000 IOPS 50 MB/s 部署云端code-server 系统环境 $ cat /etc/redhat-release CentOS Linux release 7.6.1810 (Core) 用户环境 ]# useradd code ]# echo \u0026#34;password\u0026#34; | passwd --stdin code #\u0026#34;password\u0026#34; 为code用户登录密码 部署nginx环境 ## nginx repo 源 ]# vim /etc/yum.repos.d/nginx.repo [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/7/$basearch/ gpgcheck=0 enabled=1 --------------------------------------------------------- ]# yum repolist ## 安装nginx ]# yum -y install nginx ## 转发配置 ]# vim /etc/nginx/conf.d/default.conf server { listen 80; listen 443 ssl; server_name domain; ssl_certificate cert/cert-file-name.pem; #需要将cert-file-name.pem替换成已上传的证书文件的名称。 ssl_certificate_key cert/cert-file-name.key; #需要将cert-file-name.key替换成已上传的证书私钥文件的名称。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; if ( $server_port = \u0026#34;80\u0026#34; ) { rewrite ^(/.*)$ https://$host$1 permanent; } location / { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header Upgrade $http_upgrade; # 设置websocket proxy_set_header Connection upgrade; proxy_set_header Accept-Encoding gzip; } } ## 检查配置文件语法 ]# nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 开始部署code-server # 切换普通用户 ]# su - code # 下载软件包 ]$ wget https://github.com/cdr/code-server/releases/download/v3.12.0/code-server-3.12.0-linux-amd64.tar.gz # 解包 ]$ tar xf code-server-3.12.0-linux-amd64.tar.gz \u0026amp;\u0026amp; mv code-server-3.12.0-linux-amd64 code-server \u0026amp;\u0026amp; cd code-server/ # 编辑配置文件 ]$ vim config.yaml bind-addr: 127.0.0.1:8080 auth: password password: [password] # 此处为code-server登录密码 cert: false ]$ logout # 退出普通用户环境 配置code-server服务 ]# vim /usr/lib/systemd/system/code-server.service [Unit] Description=code-server Documentation=https://docs.cloudreve.org After=network.target Wants=network.target [Service] ExecStart=/home/code/code-server/bin/code-server --config=/home/code/code-server/config.yaml Restart=on-abnormal RestartSec=5s KillMode=mixed StandardOutput=null StandardError=syslog [Install] WantedBy=multi-user.target ]# systemctl daemon-reload # 加载服务配置 添加sudo提权 ]# vim /etc/sudoers code ALL=(ALL) /bin/systemctl, /bin/netstat, /bin/ps, /usr/sbin/nginx 切换普通用户起服务 ]# su - code ]$ sudo systemctl start code-server [sudo] password for code: # 此处输入code 用户密码 ]$ sudo systemctl enable code-server [sudo] password for code: # 此处输入code 用户密码 ]$ sudo nginx [sudo] password for code: # 此处输入code 用户密码 ","date":"December 7, 2021","externalUrl":"","permalink":"/posts/code-server/","section":"笔记","summary":"搭建云端IDE教程","title":"云端IDE","type":"posts"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/artitalk/","section":"Tags","summary":"","title":"artitalk","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/asciiflow/","section":"Tags","summary":"","title":"asciiflow","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/author/","section":"Tags","summary":"","title":"author","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/authors/","section":"Tags","summary":"","title":"authors","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/blowfish/","section":"Tags","summary":"","title":"blowfish","type":"tags"},{"content":"记录一些关于blowfish主题的应用\n","date":"January 1, 1","externalUrl":null,"permalink":"/docs/theme/","section":"知识存档","summary":"记录一些关于blowfish主题的应用","title":"blowfish主题","type":"docs"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/bookstack/","section":"Tags","summary":"","title":"bookstack","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/comment/","section":"Tags","summary":"","title":"Comment","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/convertio/","section":"Tags","summary":"","title":"Convertio","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"css","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/series/css/","section":"Series","summary":"","title":"css","type":"series"},{"content":"记录一些关于前端CSS的知识。\n","date":"January 1, 1","externalUrl":null,"permalink":"/docs/css/","section":"知识存档","summary":"记录一些关于前端CSS的知识。","title":"CSS","type":"docs"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/curl/","section":"Tags","summary":"","title":"curl","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"git","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"github","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":"https://learngitbranching.js.org/?locale=zh_CN","permalink":"/tools/git/","section":"实用工具","summary":"","title":"Git在线学习","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/go/","section":"Tags","summary":"","title":"Go","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":"https://gobyexample-cn.github.io/","permalink":"/tools/go/","section":"实用工具","summary":"","title":"Go by Example 中文版","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/html/","section":"Tags","summary":"","title":"html","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/http/","section":"Tags","summary":"","title":"http","type":"tags"},{"content":" 设置网站的错误页面 如果用户端尝试看网页时遇到问题，服务器会将HTTP错误从网站发送到web浏览器。如果无法显示网页，Web浏览器会显示网站发送的实际错误网页或Web浏览器内置的友好错误信息。Nginx服务器支持自定义错误网页的显示内容。可以通过这一功能在网站发送错误时为用户提供人性化的错误显示页面。 一般来说，HTTP 2XX 代表请求正常完成，HTTP 3XX代表网站重定向，HTTP 4XX代表客户端出现错误，HTTP 5XX 代表服务器端出现错误。\nHTTP 消息 HTTP 代码 含义 已移动 HTTP 301 请求的数据具有新的位置，并且更改是永久 已找到 HTTP 302 请求的数据临时具有不同的URI 请参阅其他 HTTP 303 可在另一URI下找到对请求的响应，并且使用GET方法检索此响应 未修改 HTTP 304 未按预期修改文档 使用代理 HTTP 305 必须通过位置字段中提供的代理来访问请求的资源 未使用 HTTP 306 不再使用，但保留此代码以便将来使用 无法找到网页 HTTP 400 可以连接到web服务器，但是由于web地址(URI)的问题，无法找到网页 网站拒绝显示此网页 HTTP 403 可以连接到网站，但 Internet Explorer 没有显示网页的权限 无法找到网页 HTTP 404 可以连接到网站，但找不到网页。导致此错误的原因有可能是该网页暂时不可用或网页以被删除 网站无法显示该页面 HTTP 405 可以连接到网站，但网页内容无法下载到用户计算机。这通常是由网页编写方式问题引起的 无法读取此网页格式 HTTP 406 能够从网站接收信息，但 Internet Explorer 不能识别其格式，因而无法正确地显示消息 此网站太忙，无法显示此网页 HTTP 408 或 409 服务器显示该网页的时间太长，或对同一网页的请求太多 网页不复存在 HTTP 410 可以连接到网站，但无法找到网页。与HTTP 404不同，此错误是永久性的，而且由网站管理员打开 网站无法显示该页面 HTTP 500 正在访问的网站出现了服务器问题，该问题阻止了此网页的显示。常见的原因是网站正在维护或使用脚本的交互网站上的程序出错 未执行 HTTP 501 没有将正在访问的网站设置为显示浏览器所请求的内容 不支持的版本 HTTP 505 该网站不支持浏览器用于请求网页的HTTP协议（最常见的是HTTP/1.1） ","date":"January 1, 1","externalUrl":"","permalink":"/posts/httpstatus/","section":"笔记","summary":"常见的HTTP错误代码","title":"HTTP Status","type":"posts"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/http2/","section":"Tags","summary":"","title":"http2","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/icon/","section":"Tags","summary":"","title":"icon","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"javascript","type":"tags"},{"content":"随手记\n","date":"January 1, 1","externalUrl":null,"permalink":"/docs/linux/","section":"知识存档","summary":"随手记","title":"Linux","type":"docs"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/mermaid/","section":"Tags","summary":"","title":"mermaid","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/music/","section":"Tags","summary":"","title":"music","type":"tags"},{"content":" Nginx 服务器的高级配置 针对IPv4的内核参数优化 针对处理器的指令配置 针对网络连接的指令配置 与事件驱动相关的指令配置 ","date":"January 1, 1","externalUrl":null,"permalink":"/docs/nginx/hightconf/","section":"知识存档","summary":"Nginx服务器的高级配置","title":"Nginx 高级配置","type":"docs"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/sftp/","section":"Tags","summary":"","title":"sftp","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/shuortcode/","section":"Tags","summary":"","title":"shuortcode","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/talk/","section":"Tags","summary":"","title":"talk","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/theme/","section":"Tags","summary":"","title":"theme","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/tinyjpg/","section":"Tags","summary":"","title":"tinyjpg","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/twikoo/","section":"Tags","summary":"","title":"twikoo","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/tags/waline/","section":"Tags","summary":"","title":"waline","type":"tags"},{"content":"","date":"January 1, 1","externalUrl":"https://web.qianguyihao.com/#%E5%89%8D%E8%A8%80","permalink":"/tools/html/","section":"实用工具","summary":"","title":"千古前端图文教程","type":"tools"},{"content":"有用的链接\n","date":"January 1, 1","externalUrl":null,"permalink":"/tools/","section":"实用工具","summary":"有用的链接","title":"实用工具","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":"https://bookstack.cn","permalink":"/tools/bookstatck.cn/","section":"实用工具","summary":"","title":"书栈网","type":"tools"},{"content":" 测试1 text 纯文本测试 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus non magna ex. Donec sollicitudin ut lorem quis lobortis. Nam ac ipsum libero. Sed a ex eget ipsum tincidunt venenatis quis sed nisl. Pellentesque sed urna vel odio consequat tincidunt id ut purus. Nam sollicitudin est sed dui interdum rhoncus. 测试2 markdown markdown格式测试 hello world 测试3 shortcode 嵌套简码测试 Previous Nextsads 提示！ 这是一条测试 talk Alert alert 参考了FixIt 主题的类似alert简码的风格。 Shortcode 151 字\u0026middot; loading \u0026middot; loading 主题作者提供的一些简码很自由，定义一些简码参数的编排，方便日后快速使用 2024/03/24 · 06:14 · 深圳 不蒜子 busuanzi 今天更新了网站主页的访问量统计，采用不蒜子组件。 Busuanzi 120 字\u0026middot; loading \u0026middot; loading 给网站添加不蒜子访问量统计 2024/03/26 · 0:14 · 深圳 关于说说 原本是使用 Artitalk 来作为本站的说说，但是加载特别慢，有时甚至加载不出来，无意间看到👉 金圣皓博主的说说，觉得很不错。感兴趣的可以看看博主的 说说 关于说说，我想实现自己独特的说说页面，目前还在学习前端知识中\u0026hellip;\u0026hellip; ","date":"January 1, 1","externalUrl":null,"permalink":"/about/shuoshuo/","section":"关于","summary":"畅所欲言","title":"说说","type":"about"},{"content":"","date":"January 1, 1","externalUrl":"https://tinyjpg.com/","permalink":"/tools/tinyjpg.com/","section":"实用工具","summary":"","title":"图像压缩工具","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/authors/%E5%B0%8F%E6%A9%98%E5%AD%90single/","section":"作者","summary":"","title":"小橘子Single","type":"authors"},{"content":"","date":"January 1, 1","externalUrl":"https://asciiflow.cn","permalink":"/tools/asciiflow.cn/","section":"实用工具","summary":"","title":"在线文本流程图表","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":"https://convertio.co/zh/document-converter/","permalink":"/tools/convertio.co/","section":"实用工具","summary":"","title":"在线文档文件转换器","type":"tools"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/series/%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3/","section":"Series","summary":"","title":"主题相关文档","type":"series"},{"content":"","date":"January 1, 1","externalUrl":null,"permalink":"/authors/","section":"作者","summary":"","title":"作者","type":"authors"}]